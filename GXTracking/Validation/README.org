
This is the top level directory of Validation subpackage, which contains
the code for physics validation.

* Purpose of Physics Validation

  The purpose of the Validation package is to validate the physics of
  the processes implemented in prototypes, through detailed
  comparisons with a standard Geant4 releases.

  The idea is that a similar detector simulation environment is
  created in both versions of the validation job.  That means,
  identical geometry, magnetic field, physics lists, particle
  kinematics and statistics are used.  Moreover, for simplification
  purposes, only the first step of each primary track is simulated,
  and no secondaries are tracked.

  Variables relevant for the investigated process are histogrammed and
  the histogram compared a posteriori, using Root or PyRoot tools.


* Building instructions for the impatient

  Both validation jobs require Root, while the prototype jobs also
  require the prototype-related environments.  The configuration is
  taken care of by the CMake toolkit, but the user is required to
  provide the root configuration as usual, via the ROOTSYS variable.

  Then CMake can be launched to build the Makefiles:

-----------
  #.. create the building area, away from the source tree (see CMake docs)
  cd /path/to/build
  rm -rf CMakeFiles CMakeCache.txt Makefile cmake_install.cmake
  cmake -DCMAKE_INSTALL_PREFIX=/path/to/install -DCMAKE_BUILD_TYPE=Debug \
     -DGeant4_DIR=/path/to/patched/Geant4 \
     -DUSE_ROOT=1 -DGPUNONRANDOM=OFF -DGPUDEBUG=OFF -DGPUPLOTS=ON \
     /path/to/GXTracking/Validation

  make          # build libutils.a, Geant4-based and prototype-based binaries
  make install  # optionally install them for general use
-----------

Please note the patched version of Geant4, required for histogramming
any variable which cannot be directly accessed from user code in
e.g. UserSteppingAction classes.


** Environment variables

A few environment variables can be used for finer control of the debugging
verbosity:

GPUDEBUG=ON turns on verbosity printouts, also forcing the job to run
on a smaller number of events.  Default is OFF.

GPUNONRANDOM=ON forces the random numbers to be non-random (=0.123456
for instance).  Since the random number generators (RNGs) are
completely unrelated in Geant4 and in the prototype, an attempt was
made to create a more reproducible environment by completely
eliminating all randomness from the jobs.

GPUPLOTS=OFF will turn off all histogramming and associated calculations.
This is an attempt to run performance measurements in the validation
environment, if needed, without the performance overhead introduced by
the validation framework.


* Information for the developers

There are three subdirectories under this directory:

** utils

  Contains utility code for creating and managing validation
  histograms.  During the build process, a library gets created into
  utils/libutils.a

  For now, there is only one class, GPHistoManager, which contains
  several booking functions, like bookBremHistos().  Such methods can
  be called both from g4app and prototype jobs, ensuring that the
  histograms are created with identical parameters, for easy
  overlaying.

** g4app

  This directory contains the source code for jobs based on standard,
  (though patched) Geant4, to be used as reference for comparisons.
  Here's the sequence of calls to define and fill the validation
  histograms:

  In the main() routine, in file G4validation.cc:

-----------
  // declaration for singleton class GPHistoManager
  #include "GPHistoManager.hh"

  // get a pointer to the singleton class GPHistoManager
  GPHistoManager& hmgr = GPHistoManager::getInstance();

  // book histograms for a specific study
  hmgr.bookBremHistos();
-----------

Please note that, in practice, each group of histogramming lines above is 
usually embraced by #ifdef/#endif pairs, like so:

-----------
#ifdef GPUPLOTS
  hmgr.bookBremHistos();
#endif
-----------

for fine control if/when the user wants to disable the validation code via
switches defined at pre-processing time (see later).

The histograms can be filled in two ways, depending on how accessible
the variable is to user code.  If the variable is accessible from
UserSteppingAction, then:

----------
  // from a UserSteppingAction-like method
  #include "GPHistoManager.hh"
  GPHistoManager& hmgr = GPHistoManager::getInstance();
  hmgr.Fill("hBremHistoName", variable);
----------

If the variable is not directly accessible from user code, then
changes are needed in the Geant4 toolkit itself.  But in order to avoid
directly accessing root classes from inside Geant4, we insert a simple
container class G4dataBuffer inside Geant4 (see later for details on where
to obtain the source code):

global/management/include/G4dataBuffer.hh
global/management/src/G4dataBuffer.cc

which can then be accessed from the user code:

-----------
  // example: in processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
  #include "G4dataBuffer.hh"

  G4dataBuffer& g4buffer = G4dataBuffer::getInstance();
  g4buffer.getBuffer("hbremPreStepLambda").push_back(preStepLambda);
----------

and then, from the user code in UserSteppingAction:

----------
  #include "GPHistoManager.hh"
  #include "G4dataBuffer.hh"

  GPHistoManager& hmgr = GPHistoManager::getInstance();
  G4dataBuffer& buffers = G4dataBuffer::getInstance();

  hmgr.fillFromVector("hbremPreStepLambda", buffers.getBuffer("hbremPreStepLambda") );
----------


** prototype

Once the prototype environment (e.g. CUDA) is properly setup, the
validation executables should be automatically built.  The histograms
are filled in exactly the same way as described above, but this time
with additional environment variables, to hide the histogramming code
from the prototype processors (e.g. GPUs):

----------
#ifdef GPUPLOTS
#ifndef __CUDA_ARCH__
  // from a UserSteppingAction-like method
  #include "GPHistoManager.hh"
  GPHistoManager& hmgr = GPHistoManager::getInstance();
  hmgr.Fill("hBremHistoName", variable);
#endif // __CUDA_ARCH__
#endif // GPUPLOTS
----------

This way, the histograms will be filled using the same code which runs
on the processors, but only when running on the CPUs.
