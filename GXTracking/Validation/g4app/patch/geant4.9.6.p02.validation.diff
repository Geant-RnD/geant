diff -rupN geant4.9.6.p02-orig/source/externals/clhep/src/NonRandomEngine.cc geant4.9.6.p02/source/externals/clhep/src/NonRandomEngine.cc
--- geant4.9.6.p02-orig/source/externals/clhep/src/NonRandomEngine.cc	2013-05-24 07:21:17.000000000 -0500
+++ geant4.9.6.p02/source/externals/clhep/src/NonRandomEngine.cc	2014-01-06 13:04:54.117636374 -0600
@@ -18,6 +18,7 @@
 //
 //=========================================================================
 
+//#include "Validation/ValidationConfig.h"  // GL: adding GPU Validation config
 #include "CLHEP/Random/NonRandomEngine.h"
 #include "CLHEP/Random/engineIDulong.h"
 #include "CLHEP/Random/DoubConv.h"
@@ -52,7 +53,12 @@ void NonRandomEngine::setRandomSequence(
   assert (sequence.size() == (unsigned int)n);
   nInSeq = 0;
   sequenceHasBeenSet=true;
+#ifndef GPUDEBUG
+#warning NonRandomEngine: GPUDEBUG=undefined - Random numbers are OK
   nextHasBeenSet=false;
+#else
+#warning NonRandomEngine: GPUDEBUG=Defined - Random numbers hardcoded (fixed!)
+#endif
   return;
 }
 
@@ -77,7 +83,12 @@ double NonRandomEngine::flat() {
   }
 
   double a = nextRandom;
+#ifndef GPUDEBUG
+#warning NonRandomEngine.cc: GPUDEBUG is NOT defined! random numbers OK
   nextHasBeenSet = false;
+#else
+#warning NonRandomEngine.cc: GPUDEBUG is defined: 'random' numbers hardcoded (fixed!)
+#endif
 
   if (intervalHasBeenSet) {
     nextRandom += randomInterval;
diff -rupN geant4.9.6.p02-orig/source/geometry/navigation/src/G4Navigator.cc geant4.9.6.p02/source/geometry/navigation/src/G4Navigator.cc
--- geant4.9.6.p02-orig/source/geometry/navigation/src/G4Navigator.cc	2013-05-24 07:20:06.000000000 -0500
+++ geant4.9.6.p02/source/geometry/navigation/src/G4Navigator.cc	2014-01-06 12:56:50.918109793 -0600
@@ -1860,8 +1860,12 @@ void G4Navigator::ComputeStepLog(const G
   //  The following checks only make sense if the move is larger
   //  than the tolerance.
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   static const G4double fAccuracyForWarning   = kCarTolerance,
                         fAccuracyForException = 1000*kCarTolerance;
+#else
+  static const G4double fAccuracyForException = 1000*kCarTolerance;
+#endif
 
   G4ThreeVector OriginalGlobalpoint = fHistory.GetTopTransform().Inverse().
                                       TransformPoint(fLastLocatedPointLocal); 
@@ -1879,7 +1883,13 @@ void G4Navigator::ComputeStepLog(const G
     G4double shiftOrigin = std::sqrt(shiftOriginSafSq);
     G4double diffShiftSaf = shiftOrigin - fPreviousSafety;
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
     if( diffShiftSaf > fAccuracyForWarning )
+#else
+    // Currently the initial point of the Track is not realistic and/or the previous
+    // step is not set realistically, so this warning is triggered all the times.
+    if (0)
+#endif
     {
       G4int oldcoutPrec= G4cout.precision(8);
       G4int oldcerrPrec= G4cerr.precision(10);
@@ -1939,6 +1949,8 @@ void G4Navigator::ComputeStepLog(const G
     }
 #endif
   }
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+   // See comment above.
   G4double safetyPlus = fPreviousSafety + fAccuracyForException;
   if ( shiftOriginSafSq > sqr(safetyPlus) )
   {
@@ -1951,6 +1963,7 @@ void G4Navigator::ComputeStepLog(const G
     G4Exception("G4Navigator::ComputeStep()", "GeomNav1002",
                 JustWarning, message);
   }
+#endif
 }
 
 // ********************************************************************
diff -rupN geant4.9.6.p02-orig/source/global/management/include/G4dataBuffer.hh geant4.9.6.p02/source/global/management/include/G4dataBuffer.hh
--- geant4.9.6.p02-orig/source/global/management/include/G4dataBuffer.hh	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p02/source/global/management/include/G4dataBuffer.hh	2014-01-06 13:04:54.118636332 -0600
@@ -0,0 +1,64 @@
+//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
+//
+// File: G4dataBuffer.hh
+//
+// Purpose:
+//   Central class to centralize management of histograms and similar objects.
+//
+// This is how to use it:
+// 1. get a pointer:    G4dataBuffer* hmgr = G4dataBuffer::getInstance();
+// 2. book a histogram: TH1F* hist = hmgr->book1F("name",100,0.1);
+// 3. fill it (best):   hist->fill(value);
+// 4. also works:       hmgr->fill("name",value);
+//
+// Last method can also be called from any other place, by accessing
+// following steps 1 and 4.
+//
+// Note: make sure this class is destroyed at end of job, otherwise
+// histograms may not be saved.
+//
+// 20131209 - Guilherme Lima - Created
+//
+//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
+#ifndef _G4DATABUFFER_HH_
+#define _G4DATABUFFER_HH_
+
+#include "G4Types.hh"
+#include <string>
+#include <map>
+#include <vector>
+
+// Maps of data keyed by a string
+typedef std::map<std::string,std::vector<G4double> > DataMap;
+typedef std::map<std::string,std::vector<std::pair<G4double,G4double> > > Data2DMap;
+
+class G4dataBuffer {
+
+public:
+  static G4dataBuffer& getInstance() {
+    if( !_me ) _me = new G4dataBuffer();
+    return *_me;
+  }
+
+  void destroy();
+
+  std::vector<G4double>& getBuffer(const std::string& name);
+  std::vector< std::pair<G4double,G4double> >& getBuffer2D(const std::string& name);
+
+  void fill(std::string& name, float value);
+  void fill(std::string& name, float value, float val2);
+
+private:
+  // Constructor
+  G4dataBuffer();
+  // Destructor
+  ~G4dataBuffer();
+
+private:
+  // ***** Member data  *****
+  static G4dataBuffer* _me;  // singleton pointer
+  DataMap _map;
+  Data2DMap _map2D;
+};
+
+#endif // _G4DATABUFFER_HH_
diff -rupN geant4.9.6.p02-orig/source/global/management/sources.cmake geant4.9.6.p02/source/global/management/sources.cmake
--- geant4.9.6.p02-orig/source/global/management/sources.cmake	2013-05-24 07:20:51.000000000 -0500
+++ geant4.9.6.p02/source/global/management/sources.cmake	2014-01-06 13:04:54.133635697 -0600
@@ -36,6 +36,7 @@ GEANT4_DEFINE_MODULE(NAME G4globman
         G4ApplicationState.hh
         G4DataVector.hh
         G4DataVector.icc
+        G4dataBuffer.hh
         G4ErrorPropagatorData.hh
         G4ErrorPropagatorData.icc
         G4Evaluator.hh
@@ -92,6 +93,7 @@ GEANT4_DEFINE_MODULE(NAME G4globman
     SOURCES
         G4AllocatorPool.cc
         G4DataVector.cc
+        G4dataBuffer.cc
         G4ErrorPropagatorData.cc
         G4Exception.cc
         G4GeometryTolerance.cc
diff -rupN geant4.9.6.p02-orig/source/global/management/src/G4dataBuffer.cc geant4.9.6.p02/source/global/management/src/G4dataBuffer.cc
--- geant4.9.6.p02-orig/source/global/management/src/G4dataBuffer.cc	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p02/source/global/management/src/G4dataBuffer.cc	2014-01-06 13:04:54.140635401 -0600
@@ -0,0 +1,50 @@
+#include "G4dataBuffer.hh"
+
+using std::string;
+using std::vector;
+using std::pair;
+using std::map;
+
+G4dataBuffer* G4dataBuffer::_me = NULL;
+
+G4dataBuffer::G4dataBuffer() { }
+
+G4dataBuffer::~G4dataBuffer() {
+  this->destroy();
+}
+
+void G4dataBuffer::destroy() {
+  // first empty maps
+  _map.clear();
+  _map2D.clear();
+  // then singleton destroys itself
+  if(_me) delete _me;
+}
+
+
+std::vector<G4double>& G4dataBuffer::getBuffer(const std::string& name) {
+  DataMap::iterator iter = _map.find(name);
+  if( iter != _map.end() ) return iter->second;
+  else {
+    _map.insert( pair<string,vector<G4double> >(name,vector<double>()) );
+    return _map[name];
+  }
+}
+
+
+std::vector< std::pair<G4double,G4double> >& G4dataBuffer::getBuffer2D(const std::string& name) {
+  Data2DMap::iterator iter = _map2D.find(name);
+  if( iter != _map2D.end() ) return iter->second;
+  else {
+    _map2D.insert( pair<string,vector<pair<G4double,G4double> > >() );
+    return _map2D[name];
+  }
+}
+
+void G4dataBuffer::fill(string& name, float value) {
+  _map[name].push_back(value);
+}
+
+void G4dataBuffer::fill(string& name, float value, float val2) {
+  _map2D[name].push_back( pair<G4double,G4double>(value,val2) );
+}
diff -rupN geant4.9.6.p02-orig/source/materials/src/G4Material.cc geant4.9.6.p02/source/materials/src/G4Material.cc
--- geant4.9.6.p02-orig/source/materials/src/G4Material.cc	2013-05-24 07:19:43.000000000 -0500
+++ geant4.9.6.p02/source/materials/src/G4Material.cc	2014-01-06 13:04:54.149635019 -0600
@@ -126,6 +126,9 @@ G4Material::G4Material(const G4String& n
       else                          { fState = kStateGas; }
     }
 
+#ifdef GPUDEBUG
+  G4cout<<"G4Material constructor: calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
   ComputeDerivedQuantities();
 }
 
@@ -296,8 +299,12 @@ void G4Material::ComputeDerivedQuantitie
      VecNbOfAtomsPerVolume[i] = Avogadro*fDensity*fMassFractionVector[i]/Ai;
      TotNbOfAtomsPerVolume += VecNbOfAtomsPerVolume[i];
      TotNbOfElectPerVolume += VecNbOfAtomsPerVolume[i]*Zi;
+#ifdef GPUDEBUG
+     G4cout<<"G4Material: CompDerivedQuantities: "<< Zi <<' '<< Ai <<' '<< VecNbOfAtomsPerVolume[i]
+	   <<' '<< TotNbOfAtomsPerVolume <<' '<< TotNbOfElectPerVolume << G4endl;
+#endif
   }
-        
+
   ComputeRadiationLength();
   ComputeNuclearInterLength();
 
@@ -326,6 +333,9 @@ void G4Material::CopyPointersOfBaseMater
     VecNbOfAtomsPerVolume[i] = factor*v[i];
   }
   fRadlen = fBaseMaterial->GetRadlen()/factor;
+#ifdef GPUDEBUG
+  G4cout<<"G4Material::CopyPointersOfBaseMaterial: fRadLen="<< fRadlen <<" factor="<< factor << G4endl;
+#endif
   fNuclInterLen = fBaseMaterial->GetNuclearInterLength()/factor;
   if (fIonisation) { delete fIonisation; }
   fIonisation  = new G4IonisParamMat(this);
@@ -373,6 +383,9 @@ void G4Material::AddElement(G4Element* e
     }
 
     fMassOfMolecule = Amol/Avogadro;
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddElement(nAtoms): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -435,7 +448,10 @@ void G4Material::AddElement(G4Element* e
       fAtomsVector[i] = 
 	G4int(fMassFractionVector[i]*Amol/(*theElementVector)[i]->GetA()+0.5);
     }
-     
+
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddElement(fraction): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -527,6 +543,9 @@ void G4Material::AddMaterial(G4Material*
 	G4int(fMassFractionVector[i]*Amol/(*theElementVector)[i]->GetA()+0.5);
     }
      
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddMaterial(fraction): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -538,8 +557,17 @@ void G4Material::ComputeRadiationLength(
   G4double radinv = 0.0 ;
   for (size_t i=0;i<fNumberOfElements;++i) {
      radinv += VecNbOfAtomsPerVolume[i]*((*theElementVector)[i]->GetfRadTsai());
+#ifdef GPUDEBUG
+     G4cout<<"G4Material::ComputeRadiationLength: i="<< i <<" radinv="<< radinv
+	   <<", NbAtosPerVol="<< VecNbOfAtomsPerVolume[i]
+	   <<", Elem fRadTsai="<< ((*theElementVector)[i]->GetfRadTsai())
+	   << std::endl;
+#endif
   }
   fRadlen = (radinv <= 0.0 ? DBL_MAX : 1./radinv);
+#ifdef GPUDEBUG
+  G4cout<<"G4Material::ComputeRadiationLength: final fRadLen="<< fRadlen <<" radinv="<< radinv << G4endl;
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
@@ -670,6 +698,9 @@ const G4Material& G4Material::operator=(
 	  fMassFractionVector[i] = right.fMassFractionVector[i];
 	  fAtomsVector[i]        = right.fAtomsVector[i];
 	}
+#ifdef GPUDEBUG
+	G4cout<<"G4Material::operator=(): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
 	ComputeDerivedQuantities();
       }
       	   
diff -rupN geant4.9.6.p02-orig/source/persistency/gdml/src/G4GDMLRead.cc geant4.9.6.p02/source/persistency/gdml/src/G4GDMLRead.cc
--- geant4.9.6.p02-orig/source/persistency/gdml/src/G4GDMLRead.cc	2013-05-24 07:23:23.000000000 -0500
+++ geant4.9.6.p02/source/persistency/gdml/src/G4GDMLRead.cc	2014-01-06 12:56:50.919109750 -0600
@@ -288,7 +288,7 @@ void G4GDMLRead::Read(const G4String& fi
    xercesc::ErrorHandler* handler = new G4GDMLErrorHandler(!validate);
    xercesc::XercesDOMParser* parser = new xercesc::XercesDOMParser;
 
-   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Always);
+   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Never);
    parser->setValidationSchemaFullChecking(true);
    parser->setCreateEntityReferenceNodes(false); 
      // Entities will be automatically resolved by Xerces
diff -rupN geant4.9.6.p02-orig/source/persistency/gdml/src/G4GDMLRead.cc_1 geant4.9.6.p02/source/persistency/gdml/src/G4GDMLRead.cc_1
--- geant4.9.6.p02-orig/source/persistency/gdml/src/G4GDMLRead.cc_1	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p02/source/persistency/gdml/src/G4GDMLRead.cc_1	2014-01-06 12:56:50.937108986 -0600
@@ -0,0 +1,365 @@
+//
+// ********************************************************************
+// * License and Disclaimer                                           *
+// *                                                                  *
+// * The  Geant4 software  is  copyright of the Copyright Holders  of *
+// * the Geant4 Collaboration.  It is provided  under  the terms  and *
+// * conditions of the Geant4 Software License,  included in the file *
+// * LICENSE and available at  http://cern.ch/geant4/license .  These *
+// * include a list of copyright holders.                             *
+// *                                                                  *
+// * Neither the authors of this software system, nor their employing *
+// * institutes,nor the agencies providing financial support for this *
+// * work  make  any representation or  warranty, express or implied, *
+// * regarding  this  software system or assume any liability for its *
+// * use.  Please see the license in the file  LICENSE  and URL above *
+// * for the full disclaimer and the limitation of liability.         *
+// *                                                                  *
+// * This  code  implementation is the result of  the  scientific and *
+// * technical work of the GEANT4 collaboration.                      *
+// * By using,  copying,  modifying or  distributing the software (or *
+// * any work based  on the software)  you  agree  to acknowledge its *
+// * use  in  resulting  scientific  publications,  and indicate your *
+// * acceptance of all terms of the Geant4 Software license.          *
+// ********************************************************************
+//
+// $Id$
+//
+// class G4GDMLRead Implementation
+//
+// History:
+// - Created.                                  Zoltan Torzsok, November 2007
+// -------------------------------------------------------------------------
+
+#include "globals.hh"
+
+#include "G4GDMLRead.hh"
+
+#include "G4UnitsTable.hh"
+#include "G4Element.hh"
+#include "G4Material.hh"
+#include "G4SolidStore.hh"
+#include "G4LogicalVolumeStore.hh"
+#include "G4PhysicalVolumeStore.hh"
+
+G4GDMLRead::G4GDMLRead()
+  : validate(true), check(false), inLoop(0), loopCount(0)
+{
+   G4UnitDefinition::BuildUnitsTable();
+}
+
+G4GDMLRead::~G4GDMLRead()
+{
+}
+
+G4String G4GDMLRead::Transcode(const XMLCh* const toTranscode)
+{
+   char* char_str = xercesc::XMLString::transcode(toTranscode);
+   G4String my_str(char_str);
+   xercesc::XMLString::release(&char_str);
+   return my_str;
+}
+
+void G4GDMLRead::OverlapCheck(G4bool flag)
+{
+   check = flag;
+}
+
+G4String G4GDMLRead::GenerateName(const G4String& nameIn, G4bool strip)
+{
+   G4String nameOut(nameIn);
+
+   if (inLoop>0)
+   {
+     nameOut = eval.SolveBrackets(nameOut);
+//     std::stringstream stream;
+//     stream << "0x" << loopCount;
+//     nameOut = nameOut + stream.str();
+   }
+   if (strip) { StripName(nameOut); }
+
+   return nameOut;
+}
+
+void G4GDMLRead::GeneratePhysvolName(const G4String& nameIn,
+                                     G4VPhysicalVolume* physvol)
+{
+   G4String nameOut(nameIn);
+
+   if (nameIn.empty())
+   {
+     std::stringstream stream;
+     stream << physvol->GetLogicalVolume()->GetName() << "_PV";
+     nameOut = stream.str();
+   }
+   nameOut = eval.SolveBrackets(nameOut);
+
+   physvol->SetName(nameOut);
+}
+
+G4String G4GDMLRead::Strip(const G4String& name) const
+{
+  G4String sname(name);
+  return sname.remove(sname.find("0x"));
+}
+
+void G4GDMLRead::StripName(G4String& name) const
+{
+  name.remove(name.find("0x"));
+}
+
+void G4GDMLRead::StripNames() const
+{
+  // Strips off names of volumes, solids elements and materials from possible
+  // reference pointers or IDs attached to their original identifiers.
+
+  G4PhysicalVolumeStore* pvols = G4PhysicalVolumeStore::GetInstance();
+  G4LogicalVolumeStore* lvols = G4LogicalVolumeStore::GetInstance();
+  G4SolidStore* solids = G4SolidStore::GetInstance();
+  const G4ElementTable* elements = G4Element::GetElementTable();
+  const G4MaterialTable* materials = G4Material::GetMaterialTable();
+
+  G4cout << "Stripping off GDML names of materials, solids and volumes ..."
+         << G4endl;
+
+  G4String sname;
+  register size_t i;
+
+  // Solids...
+  //
+  for (i=0; i<solids->size(); i++)
+  {
+    G4VSolid* psol = (*solids)[i];
+    sname = psol->GetName();
+    StripName(sname);
+    psol->SetName(sname);
+  }
+
+  // Logical volumes...
+  //
+  for (i=0; i<lvols->size(); i++)
+  {
+    G4LogicalVolume* lvol = (*lvols)[i];
+    sname = lvol->GetName();
+    StripName(sname);
+    lvol->SetName(sname);
+  }
+
+  // Physical volumes...
+  //
+  for (i=0; i<pvols->size(); i++)
+  {
+    G4VPhysicalVolume* pvol = (*pvols)[i];
+    sname = pvol->GetName();
+    StripName(sname);
+    pvol->SetName(sname);
+  }
+
+  // Materials...
+  //
+  for (i=0; i<materials->size(); i++)
+  {
+    G4Material* pmat = (*materials)[i];
+    sname = pmat->GetName();
+    StripName(sname);
+    pmat->SetName(sname);
+  }
+
+  // Elements...
+  //
+  for (i=0; i<elements->size(); i++)
+  {
+    G4Element* pelm = (*elements)[i];
+    sname = pelm->GetName();
+    StripName(sname);
+    pelm->SetName(sname);
+  }
+}
+
+void G4GDMLRead::LoopRead(const xercesc::DOMElement* const element,
+     void(G4GDMLRead::*func)(const xercesc::DOMElement* const))
+{
+   G4String var;
+   G4String from;
+   G4String to;
+   G4String step;
+
+   const xercesc::DOMNamedNodeMap* const attributes = element->getAttributes();
+   XMLSize_t attributeCount = attributes->getLength();
+
+   for (XMLSize_t attribute_index=0;
+        attribute_index<attributeCount;attribute_index++)
+   {
+      xercesc::DOMNode* attribute_node = attributes->item(attribute_index);
+
+      if (attribute_node->getNodeType() != xercesc::DOMNode::ATTRIBUTE_NODE)
+      { continue; }
+
+      const xercesc::DOMAttr* const attribute
+            = dynamic_cast<xercesc::DOMAttr*>(attribute_node);   
+      if (!attribute)
+      {
+        G4Exception("G4GDMLRead::LoopRead()", "InvalidRead",
+                    FatalException, "No attribute found!");
+        return;
+      }
+      const G4String attribute_name = Transcode(attribute->getName());
+      const G4String attribute_value = Transcode(attribute->getValue());
+
+      if (attribute_name=="for")  { var = attribute_value; }  else
+      if (attribute_name=="from") { from = attribute_value; } else
+      if (attribute_name=="to")   { to = attribute_value; }   else
+      if (attribute_name=="step") { step = attribute_value; }
+   }
+
+   if (var.empty())
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "No variable is determined for loop!");
+   }
+
+   if (!eval.IsVariable(var))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Variable is not defined in loop!");
+   }
+
+   G4int _var = eval.EvaluateInteger(var);
+   G4int _from = eval.EvaluateInteger(from);
+   G4int _to = eval.EvaluateInteger(to);
+   G4int _step = eval.EvaluateInteger(step);
+   
+   if (!from.empty()) { _var = _from; }
+
+   if (_from == _to)
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Empty loop!");
+   }
+   if ((_from < _to) && (_step <= 0))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Infinite loop!");
+   }
+   if ((_from > _to) && (_step >= 0))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Infinite loop!");
+   }
+
+   inLoop++;
+
+   while (_var <= _to)
+   {
+      eval.SetVariable(var,_var);
+      (this->*func)(element);
+      _var += _step;
+      loopCount++;
+   }
+
+   inLoop--;
+   if (!inLoop) { loopCount = 0; }
+}
+
+void G4GDMLRead::ExtensionRead(const xercesc::DOMElement* const)
+{
+   G4String error_msg = "No handle to user-code for parsing extensions!";
+   G4Exception("G4GDMLRead::ExtensionRead()",
+               "NotImplemented", JustWarning, error_msg);
+}
+
+void G4GDMLRead::Read(const G4String& fileName,
+                            G4bool validation,
+                            G4bool isModule,
+                            G4bool strip)
+{
+   if (isModule)
+   {
+      G4cout << "G4GDML: Reading module '" << fileName << "'..." << G4endl;
+   }
+   else
+   {
+      G4cout << "G4GDML: Reading '" << fileName << "'..." << G4endl;
+   }
+
+   inLoop = 0;
+   validate = validation;
+
+   xercesc::ErrorHandler* handler = new G4GDMLErrorHandler(!validate);
+   xercesc::XercesDOMParser* parser = new xercesc::XercesDOMParser;
+
+   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Always);
+   parser->setValidationSchemaFullChecking(true);
+   parser->setCreateEntityReferenceNodes(false); 
+     // Entities will be automatically resolved by Xerces
+
+   parser->setDoNamespaces(true);
+   parser->setDoSchema(true);
+   parser->setErrorHandler(handler);
+
+   try { parser->parse(fileName.c_str()); }
+   catch (const xercesc::XMLException &e)
+     { G4cout << "G4GDML: " << Transcode(e.getMessage()) << G4endl; }
+   catch (const xercesc::DOMException &e)
+     { G4cout << "G4GDML: " << Transcode(e.getMessage()) << G4endl; }
+
+   xercesc::DOMDocument* doc = parser->getDocument();
+
+   if (!doc)
+   {
+     G4String error_msg = "Unable to open document: " + fileName;
+     G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                 FatalException, error_msg);
+     return;
+   }
+   xercesc::DOMElement* element = doc->getDocumentElement();
+
+   if (!element)
+   {
+     G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                 FatalException, "Empty document!");
+     return;
+   }
+
+   for (xercesc::DOMNode* iter = element->getFirstChild();
+        iter != 0; iter = iter->getNextSibling())
+   {
+      if (iter->getNodeType() != xercesc::DOMNode::ELEMENT_NODE)  { continue; }
+
+      const xercesc::DOMElement* const child
+            = dynamic_cast<xercesc::DOMElement*>(iter);
+      if (!child)
+      {
+        G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                    FatalException, "No child found!");
+        return;
+      }
+      const G4String tag = Transcode(child->getTagName());
+
+      if (tag=="define")    { DefineRead(child);    } else
+      if (tag=="materials") { MaterialsRead(child); } else
+      if (tag=="solids")    { SolidsRead(child);    } else
+      if (tag=="setup")     { SetupRead(child);     } else
+      if (tag=="structure") { StructureRead(child); } else
+      if (tag=="extension") { ExtensionRead(child); }
+      else
+      {
+        G4String error_msg = "Unknown tag in gdml: " + tag;
+        G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                    FatalException, error_msg);
+      }
+   }
+
+   delete parser;
+   delete handler;
+
+   if (isModule)
+   {
+      G4cout << "G4GDML: Reading module '" << fileName << "' done!" << G4endl;
+   }
+   else
+   {
+      G4cout << "G4GDML: Reading '" << fileName << "' done!" << G4endl;
+      if (strip)  { StripNames(); }
+   }
+}
diff -rupN geant4.9.6.p02-orig/source/processes/cuts/src/G4ProductionCutsTable.cc geant4.9.6.p02/source/processes/cuts/src/G4ProductionCutsTable.cc
--- geant4.9.6.p02-orig/source/processes/cuts/src/G4ProductionCutsTable.cc	2013-05-24 07:23:20.000000000 -0500
+++ geant4.9.6.p02/source/processes/cuts/src/G4ProductionCutsTable.cc	2014-01-06 13:05:37.458799962 -0600
@@ -162,6 +162,9 @@ void G4ProductionCutsTable::UpdateCouple
    if((*rItr)->IsInMassGeometry() || (*rItr)->IsInParallelGeometry())
    {
 
+     G4cout<<"G4ProductionCutsTable.cc: Updating material-cut-couple for region: "<< (*rItr)->GetName()
+	   <<" -- #mats="<< (*rItr)->GetNumberOfMaterials() << G4endl;
+
     G4ProductionCuts* fProductionCut = (*rItr)->GetProductionCuts();
     std::vector<G4Material*>::const_iterator mItr =
       (*rItr)->GetMaterialIterator();
@@ -174,10 +177,12 @@ void G4ProductionCutsTable::UpdateCouple
       G4MaterialCutsCouple* aCouple;
       for(CoupleTableIterator cItr=coupleTable.begin();
           cItr!=coupleTable.end();cItr++){
+	G4cout<<"G4ProductionCutsTable.cc: checking next coupleIterator: "<< (*cItr) << G4endl;
         if( (*cItr)->GetMaterial()==(*mItr)    && 
 	    (*cItr)->GetProductionCuts()==fProductionCut){ 
           coupleAlreadyDefined = true;
           aCouple = *cItr;
+	  G4cout<<"G4ProductionCutsTable.cc: couple already defined: material="<< (*mItr) <<" "<< (*mItr)->GetName() << G4endl;
           break;
         }
       }
@@ -185,6 +190,7 @@ void G4ProductionCutsTable::UpdateCouple
       // If this combination is new, cleate and register a couple
       if(!coupleAlreadyDefined){
         aCouple = new G4MaterialCutsCouple((*mItr),fProductionCut);
+	G4cout<<"G4ProductionCutsTable.cc: new couple created: "<< aCouple <<", material="<< (*mItr) <<" "<< (*mItr)->GetName() << G4endl;
         coupleTable.push_back(aCouple);
         aCouple->SetIndex(coupleTable.size()-1);
       }
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc	2014-01-06 12:56:50.949108480 -0600
@@ -120,9 +120,14 @@ G4eBremsstrahlung::InitialiseEnergyLossP
   if(!isInitialised) {
 
     //    if (!EmModel(1)) { SetEmModel(new G4eBremsstrahlungModel(), 1); }
+#ifdef NO_BACKPORT_CUDA_REMOVALS
     if (!EmModel(1)) { SetEmModel(new G4SeltzerBergerModel(), 1); }
     if (!EmModel(2)) { SetEmModel(new G4eBremsstrahlungRelModel(), 2); }
-
+#else
+    if (!EmModel(1)) { SetEmModel(new G4eBremsstrahlungModel(), 1); }
+    if (!EmModel(2)) { SetEmModel(new G4eBremsstrahlungModel(), 2); }
+#endif
+     
     G4double energyLimit = 1*GeV;
 
     EmModel(1)->SetLowEnergyLimit(MinKinEnergy());
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc	2014-01-06 12:56:50.958108098 -0600
@@ -638,6 +638,223 @@ G4DataVector* G4eBremsstrahlungModel::Co
   return dv;
 }
 
+#if 0
+
+static G4double ComputeCrossSectionPerAtom(double kineticEnergy, double Z,
+                                            G4double cut) {
+	G4double cross = 0.0;
+   
+	if (kineticEnergy < keV || kineticEnergy < cut) {
+		return cross;
+	}
+   
+	const G4double ksi = 2.0;
+	//  const G4double alfa=1.00;
+	const G4double csigh = 0.127, csiglow = 0.25, asiglow = 0.020 * MeV;
+	const G4double Tlim = 10. * MeV;
+   
+	const G4double xlim = 1.2;
+   
+	const int NZ = 8;
+	const int Nsig = 11;
+	const float ZZ[NZ] = { 2., 4., 6., 14., 26., 50., 82., 92. };
+	const float coefsig[NZ][Nsig] = { { 0.4638, 0.37748, 0.32249, -0.060362,
+      -0.065004, -0.033457, -0.004583, 0.011954, 0.0030404, -0.0010077,
+      -0.00028131 },
+      
+      { 0.50008, 0.33483, 0.34364, -0.086262, -0.055361, -0.028168, -0.0056172,
+			0.011129, 0.0027528, -0.00092265, -0.00024348 },
+      
+      { 0.51587, 0.31095, 0.34996, -0.11623, -0.056167, -0.0087154, 0.00053943,
+			0.0054092, 0.00077685, -0.00039635, -6.7818e-05 },
+      
+      { 0.55058, 0.25629, 0.35854, -0.080656, -0.054308, -0.049933, -0.00064246,
+			0.016597, 0.0021789, -0.001327, -0.00025983 },
+      
+      { 0.5791, 0.26152, 0.38953, -0.17104, -0.099172, 0.024596, 0.023718,
+			-0.0039205, -0.0036658, 0.00041749, 0.00023408 },
+      
+      { 0.62085, 0.27045, 0.39073, -0.37916, -0.18878, 0.23905, 0.095028,
+			-0.068744, -0.023809, 0.0062408, 0.0020407 },
+      
+      { 0.66053, 0.24513, 0.35404, -0.47275, -0.22837, 0.35647, 0.13203, -0.1049,
+			-0.034851, 0.0095046, 0.0030535 },
+      
+      { 0.67143, 0.23079, 0.32256, -0.46248, -0.20013, 0.3506, 0.11779, -0.1024,
+			-0.032013, 0.0092279, 0.0028592 } };
+   
+	int iz = 0;
+	G4double delz = 1.0e6;
+	for (int ii = 0; ii < NZ; ii++) {
+		G4double absdelz = fabs(Z - ZZ[ii]);
+		if (absdelz < delz) {
+			iz = ii;
+			delz = absdelz;
+		}
+	}
+   
+	G4double xx = log10(kineticEnergy / MeV);
+	G4double fs = 1.0;
+   
+	if (xx <= xlim) {
+		fs = coefsig[iz][Nsig - 1];
+		for (int j = Nsig - 2; j >= 0; j--) {
+			fs = fs * xx + coefsig[iz][j];
+		}
+		if (fs < 0.0) {
+			fs = 0.0;
+		}
+	}
+   
+	//  cross = Z*(Z+ksi)*(1.-csigh*exp(log(Z)/4.))*pow(log(kineticEnergy/cut),alfa);
+	cross = Z * (Z + ksi) * (1. - csigh * exp(log(Z) / 4.))
+   * log(kineticEnergy / cut);
+   
+	if (kineticEnergy <= Tlim) {
+		cross *= exp(csiglow * log(Tlim / kineticEnergy))
+      * (1. + asiglow / (sqrt(Z) * kineticEnergy));
+	}
+   
+	if (!isElectron)
+		cross *= PositronCorrFactorSigma(Z, kineticEnergy, cut);
+   
+	cross *= fs / Avogadro;
+   
+	if (cross < 0.0) {
+		cross = 0.0;
+	}
+   
+	return cross;
+}
+
+static G4double CrossSectionPerVolume(double kineticEnergy,
+                               G4double cutEnergy, double maxEnergy) {
+   
+	G4double cross = 0.0;
+	G4double tmax = (maxEnergy < kineticEnergy) ? maxEnergy : kineticEnergy;
+	G4double cut = (cutEnergy < kineticEnergy) ? cutEnergy : kineticEnergy;
+	if (cut >= tmax) {
+		return cross;
+	}
+   
+	// material : PbWO4
+	// density : 5.16797e+19
+	// electron density : 2.06011e+21
+	// radlen : 8.92421
+	// effZ, effA : 68.3599, 170.87
+	// name: Lead, symbol:Pb, Z: 82, density: 1.0958e+19
+	// name: Tungstenm, symbol:W, Z: 74, density: 1.0958e+19
+	// name: Oxygen, symbol:O2, Z: 8, density: 4.3832e+19
+   
+	const int nElements = 3;
+	const G4double theAtomNumDensity[nElements] = { 1.0958e+19, 1.0958e+19,
+      4.3832e+19 };
+	const G4double Z[nElements] = { 82, 74, 8 };
+   
+	for (int i = 0; i < nElements; i++) {
+		cross += theAtomNumDensity[i]
+      * ComputeCrossSectionPerAtom(kineticEnergy, Z[i], cut);
+		if (tmax < kineticEnergy) {
+			cross -= theAtomNumDensity[i]
+         * ComputeCrossSectionPerAtom(kineticEnergy, Z[i], tmax);
+		}
+	}
+   
+	// now compute the correction due to the supression(s)
+   
+	G4double kmax = tmax;
+	G4double kmin = cut;
+   
+	G4double totalEnergy = kineticEnergy + electron_mass_c2;
+	//  G4double kp2 = MigdalConstant*totalEnergy*totalEnergy
+	//                                             *(material->GetElectronDensity());
+	G4double MigdalConstant = classic_electr_radius * electron_Compton_length
+   * electron_Compton_length * 4.0 * pi;
+	// PbW04 electorn density : 2.06011e+21
+	G4double kp2 = MigdalConstant * totalEnergy * totalEnergy * 2.06011e+21;
+   
+	G4double fsig = 0.;
+	int nmax = 100;
+	G4double vmin = log(kmin);
+	G4double vmax = log(kmax);
+	G4double highKinEnergy = 100.0 * TeV;
+	int nn = (int) (nmax * (vmax - vmin) / (log(highKinEnergy) - vmin));
+	G4double u, fac, c, v, dv, y;
+	if (nn > 0) {
+      
+		dv = (vmax - vmin) / nn;
+		v = vmin - dv;
+		for (int n = 0; n <= nn; n++) {
+         
+			v += dv;
+			u = exp(v);
+			fac = SupressionFunction(kineticEnergy, u, LPMFlag);
+			y = u / kmax;
+			fac *= (4. - 4. * y + 3. * y * y) / 3.;
+			//        fac *= probsup*(u*u/(u*u+kp2))+1.-probsup;
+			fac *= (u * u / (u * u + kp2));
+         
+			if ((n == 0) || (n == nn))
+				c = 0.5;
+			else
+				c = 1.;
+         
+			fac *= c;
+			fsig += fac;
+		}
+		y = kmin / kmax;
+		fsig *= dv
+      / (-4. * log(y) / 3. - 4. * (1. - y) / 3. + 0.5 * (1. - y * y));
+      
+	} else {
+      
+		fsig = 1.;
+	}
+	if (fsig > 1.)
+		fsig = 1.;
+   
+	// correct the cross section
+	cross *= fsig;
+   
+	return cross;
+   
+}
+
+static G4double GXBrem_GPVEmModel_CrossSectionPerVolume(double ekin, double emin,
+                                                  G4double emax) {
+	G4double cross = 0.0;
+	const G4double theAtomNumDensity[nElements] = { 1.0958e+19, 1.0958e+19,
+      4.3832e+19 };
+   
+	for (int i = 0; i < nElements; i++) {
+		cross += theAtomNumDensity[i]
+      * ComputeCrossSectionPerAtom(ekin, emin, emax);
+		xsec[i] = cross;
+	}
+	return cross;
+}
+
+//int GPVEmModel_SelectRandomAtom(G4double kinEnergy, double tcut, double tmax) {
+static int GXBrem__SelectRandomAtom(G4double kinEnergy, double tcut, double tmax) {
+   // Note that in Geant4, the function actually called is G4VEmModel::SelectRandomAtom
+   // (which requires quite a bit more setup that is currently done/ported here)
+   
+   const nElements = 3;
+	int n = nElements - 1;
+	if (n > 0) {
+		G4double x = rand_wrapper(localState)
+      * GXBrem_GPVEmModel_CrossSectionPerVolume(kinEnergy, tcut, tmax);
+		for (int i = 0; i < n; ++i) {
+			if (x <= xsec[i]) {
+				return i;
+			}
+		}
+	}
+	return n;
+}
+
+#endif
+
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
 
 void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp, 
@@ -690,15 +907,53 @@ void G4eBremsstrahlungModel::SampleSecon
 
   G4double gammaEnergy;
   G4bool LPMOK = false;
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   const G4Material* material = couple->GetMaterial();
-
+#else
+  if(couple) { }; // eliminate compiler warning about unused variable
+#endif
+   
   // select randomly one element constituing the material
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   const G4Element* anElement = SelectRandomAtom(couple);
-
-  // Extract Z factors for this Element
-  G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
-  G4double FZ = lnZ* (4.- 0.55*lnZ);
-  G4double ZZ = anElement->GetIonisation()->GetZZ3();
+   
+   // Extract Z factors for this Element
+   G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
+   G4double FZ = lnZ* (4.- 0.55*lnZ);
+   G4double ZZ = anElement->GetIonisation()->GetZZ3();
+#else
+	// moved to GPConstants.h
+	// const int nElements = 3;
+	// const G4double theAtomNumDensity[nElements] = {1.0958e+19, 1.0958e+19, 4.3832e+19};
+	// const G4double Z[nElements] = {82, 74, 8};
+   
+	// tcut = 0.00099 MeV used above in GXBrem::GetCurrentLambda, taken from eBremsstralung
+   G4Material *material = G4Material::GetMaterial("PbWO4");
+   const G4Element* anElement = G4VEmModel::SelectRandomAtom(material,dp->GetParticleDefinition(),kineticEnergy,tmax);
+
+   G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
+   G4double FZ = lnZ* (4.- 0.55*lnZ);
+   G4double ZZ = anElement->GetIonisation()->GetZZ3();
+
+//   int iElement = SelectRandomAtom(kineticEnergy, 0.00099, tmax);
+//   
+//	//  const G4double theAtomNumDensity[nElements] = {1.0958e+19, 1.0958e+19, 4.3832e+19};
+//
+//	const int nElements = 3;
+//	const G4double Z[nElements] = { 82, 74, 8 };
+//   
+//	// from G4IonisParamElm.hh
+//	//G4double fZ;                 // effective Z
+//	//G4double fZ3;                // std::pow (Z,1/3)
+//	//G4double fZZ3;               // std::pow (Z(Z+1),1/3)
+//	//G4double flogZ3;             // std::log(Z)/3
+//   
+//	// Extract Z factors for this Element
+//	G4double lnZ = 3. * pow(Z[iElement], 1 / 3.);
+//	G4double FZ = log(Z[iElement]) * (4. - 0.55 * log(Z[iElement]));
+//	G4double ZZ = pow(Z[iElement] * (Z[iElement] + 1), 1 / 3.);
+   
+#endif
 
   // limits of the energy sampling
   G4double totalEnergy = kineticEnergy + electron_mass_c2;
@@ -821,6 +1076,7 @@ void G4eBremsstrahlungModel::SampleSecon
 
   } while (!LPMOK);
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   //
   // angles of the emitted gamma. ( Z - axis along the parent particle)
   // use general interface
@@ -858,6 +1114,9 @@ void G4eBremsstrahlungModel::SampleSecon
     fParticleChange->SetProposedMomentumDirection(direction);
     fParticleChange->SetProposedKineticEnergy(finalE);
   }
+#else
+  if(vdp) { }; // eliminate compiler warning about unused variable
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
@@ -865,31 +1124,31 @@ void G4eBremsstrahlungModel::SampleSecon
 const G4Element* G4eBremsstrahlungModel::SelectRandomAtom(
            const G4MaterialCutsCouple* couple) 
 {
-  // select randomly 1 element within the material
-
-  const G4Material* material = couple->GetMaterial();
-  G4int nElements = material->GetNumberOfElements();
-  const G4ElementVector* theElementVector = material->GetElementVector();
+   // select randomly 1 element within the material
 
-  const G4Element* elm = 0;
-
-  if(1 < nElements) {
-
-    --nElements; 
-    G4DataVector* dv = partialSumSigma[couple->GetIndex()];
-    G4double rval = G4UniformRand()*((*dv)[nElements]);
-
-    elm = (*theElementVector)[nElements];
-    for (G4int i=0; i<nElements; ++i) {
-      if (rval <= (*dv)[i]) {
-	elm = (*theElementVector)[i];
-	break;
+   const G4Material* material = couple->GetMaterial();
+   G4int nElements = material->GetNumberOfElements();
+   const G4ElementVector* theElementVector = material->GetElementVector();
+
+   const G4Element* elm = 0;
+
+   if(1 < nElements) {
+
+      --nElements;
+      G4DataVector* dv = partialSumSigma[couple->GetIndex()];
+      G4double rval = G4UniformRand()*((*dv)[nElements]);
+
+      elm = (*theElementVector)[nElements];
+      for (G4int i=0; i<nElements; ++i) {
+         if (rval <= (*dv)[i]) {
+            elm = (*theElementVector)[i];
+            break;
+         }
       }
-    }
-  } else { elm = (*theElementVector)[0]; }
+   } else { elm = (*theElementVector)[0]; }
  
-  SetCurrentElement(elm);
-  return elm;
+   SetCurrentElement(elm);
+   return elm;
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc	2014-01-06 13:05:37.466799623 -0600
@@ -148,6 +148,12 @@ void G4eBremsstrahlungRelModel::SetupFor
 {
   densityFactor = mat->GetElectronDensity()*fMigdalConstant;
   lpmEnergy = mat->GetRadlen()*fLPMconstant;
+#ifdef GPUDEBUG
+  G4cout<<"GPSeltzer::SetupForMaterial: fMigdalC="<< fMigdalConstant
+	<<", fLPM="<< fLPMconstant
+	<<", densityFac="<< densityFactor
+	<<", lpmEnergy="<< lpmEnergy << G4endl;
+#endif
 
   // Threshold for LPM effect (i.e. below which LPM hidden by density effect) 
   if (LPMFlag()) {
@@ -164,6 +170,15 @@ void G4eBremsstrahlungRelModel::SetupFor
   klpm=totalEnergy*totalEnergy/lpmEnergy;
   kp=sqrt(densityCorr);
     
+#ifdef GPUDEBUG
+  G4cout<<"GPSeltzer::SetupForMaterial: EneThreshLPM="<< energyThresholdLPM
+	<<", kinEne="<< kinEnergy
+	<<", totEne="<< totalEnergy
+	<<", densityCorr="<< densityCorr
+	<<", klpm="<< klpm
+	<<", kp="<< kp
+	<< G4endl;
+#endif
 }
 
 
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc	2014-01-06 13:05:37.474799285 -0600
@@ -189,6 +189,12 @@ G4double G4MollerBhabhaModel::CrossSecti
                                                  G4double maxEnergy)
 {
   G4double eDensity = material->GetElectronDensity();
+
+  G4cout<<" G4MollerBhabhaModel.cc::xSecPerVolume: "<< kinEnergy
+	<<' '<< eDensity
+	<<' '<< ComputeCrossSectionPerElectron(p,kinEnergy,cutEnergy,maxEnergy)
+	<< G4endl;
+
   return eDensity*ComputeCrossSectionPerElectron(p,kinEnergy,cutEnergy,maxEnergy);
   /*
   G4double Zeff     = eDensity/material->GetTotNbOfAtomsPerVolume();
@@ -363,6 +369,7 @@ void G4MollerBhabhaModel::SampleSecondar
     } while(grej * G4UniformRand() > z);
   }
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   G4double deltaKinEnergy = x * kineticEnergy;
 
   G4double deltaMomentum =
@@ -390,6 +397,10 @@ void G4MollerBhabhaModel::SampleSecondar
   G4DynamicParticle* delta = new G4DynamicParticle(theElectron,
 						   deltaDirection,deltaKinEnergy);
   vdp->push_back(delta);
+#else
+  if(vdp || totalMomentum) { }; // eliminate compiler warning about unused variables
+   // dwjang : wait until deciding how to handle secondaries
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc	2014-01-06 13:05:37.483798903 -0600
@@ -210,11 +210,21 @@ G4SeltzerBergerModel::SampleSecondaries(
 					G4double cutEnergy,
 					G4double maxEnergy)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+#else
+   return;
+#endif
   G4double kineticEnergy = dp->GetKineticEnergy();
+#ifdef GPUDEBUG
+  G4cout<<"G4Seltzer: vdp="<< vdp <<", couple="<< couple <<", dp="<< dp <<" cutEn="<< cutEnergy <<", kinE="<< kineticEnergy << G4endl;
+#endif
+
   G4double cut  = std::min(cutEnergy, kineticEnergy);
   G4double emax = std::min(maxEnergy, kineticEnergy);
   if(cut >= emax) { return; }
-
+#ifdef GPUDEBUG
+  G4cout<<"kinE="<< kineticEnergy <<" cut="<< cut <<" emax="<< emax <<".  Calling SetupForMaterial..."<< G4endl;
+#endif
   SetupForMaterial(particle, couple->GetMaterial(), kineticEnergy);
 
   const G4Element* elm = 
@@ -225,16 +235,25 @@ G4SeltzerBergerModel::SampleSecondaries(
   totalEnergy = kineticEnergy + particleMass;
   densityCorr = densityFactor*totalEnergy*totalEnergy;
   G4double totMomentum = sqrt(kineticEnergy*(totalEnergy + electron_mass_c2));
-  /*
+
+#ifdef GPUDEBUG
   G4cout << "G4SeltzerBergerModel::SampleSecondaries E(MeV)= " 
 	 << kineticEnergy/MeV
 	 << " Z= " << Z << " cut(MeV)= " << cut/MeV 
 	 << " emax(MeV)= " << emax/MeV << " corr= " << densityCorr << G4endl;
-  */
+#endif
+
   G4double xmin = log(cut*cut + densityCorr);
   G4double xmax = log(emax*emax  + densityCorr);
   G4double y = log(kineticEnergy/MeV);
 
+#ifdef GPUDEBUG
+  std::cout<<"SB model: kinE="<< kineticEnergy <<" cut="<< cut <<" emax="<< emax <<".  Calling SetupForMaterial..."<< std::endl;
+
+  std::cout<<"SB model: Z="<< Z <<", totE="<< totalEnergy <<", densCorr="<< densityCorr
+	   <<" xmin="<< xmin <<" xmax="<< xmax <<", y="<< y << std::endl;
+#endif
+
   G4double gammaEnergy, v; 
 
   // majoranta
@@ -253,16 +272,23 @@ G4SeltzerBergerModel::SampleSecondaries(
   }
   if(x0 < 0.05) { vmax *= 1.2; }
 
-  //G4cout<<"y= "<<y<<" xmin= "<<xmin<<" xmax= "<<xmax<<" vmax= "<<vmax<<G4endl;
-  //  G4int ncount = 0;
   do {
     //++ncount;
-    G4double x = exp(xmin + G4UniformRand()*(xmax - xmin)) - densityCorr;
+    G4double auxrand = G4UniformRand();
+    G4double x = exp(xmin + auxrand*(xmax - xmin)) - densityCorr;
     if(x < 0.0) { x = 0.0; }
     gammaEnergy = sqrt(x);
     G4double x1 = gammaEnergy/kineticEnergy;
     v = dataSB[Z]->Value(x1, y);
 
+#ifdef GPUDEBUG
+    std::cout<<"SB model: auxrand="<< auxrand
+	     <<", gammaEne="<< gammaEnergy
+	     <<", x1="<< x1 <<", y="<< y
+	     <<", v="<< v
+	     << std::endl;
+#endif
+
     // correction for positrons        
     if(!isElectron) {
       G4double e1 = kineticEnergy - cut;
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc.orig geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc.orig
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc.orig	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc.orig	2014-01-06 12:56:50.977107291 -0600
@@ -0,0 +1,344 @@
+//
+// ********************************************************************
+// * License and Disclaimer                                           *
+// *                                                                  *
+// * The  Geant4 software  is  copyright of the Copyright Holders  of *
+// * the Geant4 Collaboration.  It is provided  under  the terms  and *
+// * conditions of the Geant4 Software License,  included in the file *
+// * LICENSE and available at  http://cern.ch/geant4/license .  These *
+// * include a list of copyright holders.                             *
+// *                                                                  *
+// * Neither the authors of this software system, nor their employing *
+// * institutes,nor the agencies providing financial support for this *
+// * work  make  any representation or  warranty, express or implied, *
+// * regarding  this  software system or assume any liability for its *
+// * use.  Please see the license in the file  LICENSE  and URL above *
+// * for the full disclaimer and the limitation of liability.         *
+// *                                                                  *
+// * This  code  implementation is the result of  the  scientific and *
+// * technical work of the GEANT4 collaboration.                      *
+// * By using,  copying,  modifying or  distributing the software (or *
+// * any work based  on the software)  you  agree  to acknowledge its *
+// * use  in  resulting  scientific  publications,  and indicate your *
+// * acceptance of all terms of the Geant4 Software license.          *
+// ********************************************************************
+//
+// $Id$
+//
+// -------------------------------------------------------------------
+//
+// GEANT4 Class file
+//
+//
+// File name:     G4SeltzerBergerModel
+//
+// Author:        Vladimir Ivanchenko use inheritance from Andreas Schaelicke
+//                base class implementing ultra relativistic bremsstrahlung
+//                model 
+//
+// Creation date: 04.10.2011
+//
+// Modifications:
+//
+// -------------------------------------------------------------------
+//
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+#include "G4SeltzerBergerModel.hh"
+#include "G4PhysicalConstants.hh"
+#include "G4SystemOfUnits.hh"
+#include "G4Electron.hh"
+#include "G4Positron.hh"
+#include "G4Gamma.hh"
+#include "Randomize.hh"
+#include "G4Material.hh"
+#include "G4Element.hh"
+#include "G4ElementVector.hh"
+#include "G4ProductionCutsTable.hh"
+#include "G4ParticleChangeForLoss.hh"
+#include "G4LossTableManager.hh"
+#include "G4ModifiedTsai.hh"
+
+#include "G4Physics2DVector.hh"
+
+#include "G4ios.hh"
+#include <fstream>
+#include <iomanip>
+
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+using namespace std;
+
+G4Physics2DVector* G4SeltzerBergerModel::dataSB[101] = {0};
+G4double G4SeltzerBergerModel::ylimit[101] = {0.0};
+G4double G4SeltzerBergerModel::expnumlim = -12.;
+
+G4SeltzerBergerModel::G4SeltzerBergerModel(const G4ParticleDefinition* p,
+					   const G4String& nam)
+  : G4eBremsstrahlungRelModel(p,nam),useBicubicInterpolation(false)
+{
+  SetLowEnergyLimit(0.0);
+  SetLPMFlag(false);
+  nwarn = 0;
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+G4SeltzerBergerModel::~G4SeltzerBergerModel()
+{
+  for(size_t i=0; i<101; ++i) { 
+    if(dataSB[i]) {
+      delete dataSB[i]; 
+      dataSB[i] = 0;
+    } 
+  }
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+void G4SeltzerBergerModel::Initialise(const G4ParticleDefinition* p,
+				      const G4DataVector& cuts)
+{
+  // check environment variable
+  // Build the complete string identifying the file with the data set
+  char* path = getenv("G4LEDATA");
+
+  // Access to elements
+  const G4ElementTable* theElmTable = G4Element::GetElementTable();
+  size_t numOfElm = G4Element::GetNumberOfElements();
+  if(numOfElm > 0) {
+    for(size_t i=0; i<numOfElm; ++i) {
+      G4int Z = G4int(((*theElmTable)[i])->GetZ());
+      if(Z < 1)        { Z = 1; }
+      else if(Z > 100) { Z = 100; }
+      //G4cout << "Z= " << Z << G4endl;
+      // Initialisation
+      if(!dataSB[Z]) { ReadData(Z, path); }
+    }
+  }
+
+  G4eBremsstrahlungRelModel::Initialise(p, cuts);
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+void G4SeltzerBergerModel::ReadData(size_t Z, const char* path)
+{
+  //  G4cout << "ReadData Z= " << Z << G4endl;
+  // G4cout << "Status for Z= " << dataSB[Z] << G4endl;
+  //if(path) { G4cout << path << G4endl; }
+  if(dataSB[Z]) { return; }
+  const char* datadir = path;
+
+  if(!datadir) {
+    datadir = getenv("G4LEDATA");
+    if(!datadir) {
+      G4Exception("G4SeltzerBergerModel::ReadData()","em0006",FatalException,
+		  "Environment variable G4LEDATA not defined");
+      return;
+    }
+  }
+  std::ostringstream ost;
+  ost << datadir << "/brem_SB/br" << Z;
+  std::ifstream fin(ost.str().c_str());
+  if( !fin.is_open()) {
+    G4ExceptionDescription ed;
+    ed << "Bremsstrahlung data file <" << ost.str().c_str()
+       << "> is not opened!" << G4endl;
+    G4Exception("G4SeltzerBergerModel::ReadData()","em0003",FatalException,
+		ed,"G4LEDATA version should be G4EMLOW6.23 or later.");
+    return;
+  } 
+  //G4cout << "G4SeltzerBergerModel read from <" << ost.str().c_str() 
+  //	 << ">" << G4endl;
+  G4Physics2DVector* v = new G4Physics2DVector();
+  const G4double emaxlog = 4*log(10.);
+  if(v->Retrieve(fin)) { 
+    if(useBicubicInterpolation) { v->SetBicubicInterpolation(true); }
+    dataSB[Z] = v; 
+    ylimit[Z] = v->Value(0.97, emaxlog);
+  } else {
+    G4ExceptionDescription ed;
+    ed << "Bremsstrahlung data file <" << ost.str().c_str()
+       << "> is not retrieved!" << G4endl;
+    G4Exception("G4SeltzerBergerModel::ReadData()","em0005",FatalException,
+		ed,"G4LEDATA version should be G4EMLOW6.23 or later.");
+    delete v;
+  }
+  // G4cout << dataSB[Z] << G4endl;
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+G4double G4SeltzerBergerModel::ComputeDXSectionPerAtom(G4double gammaEnergy)
+{
+
+  if(gammaEnergy < 0.0 || kinEnergy <= 0.0) { return 0.0; }
+  G4double x = gammaEnergy/kinEnergy;
+  G4double y = log(kinEnergy/MeV);
+  G4int Z = G4int(currentZ);
+  //G4cout << "G4SeltzerBergerModel::ComputeDXSectionPerAtom Z= " << Z
+  //	 << " x= " << x << " y= " << y << " " << dataSB[Z] << G4endl;
+  if(!dataSB[Z]) { ReadData(Z); }
+  G4double invb2 = totalEnergy*totalEnergy/(kinEnergy*(kinEnergy + 2*particleMass));
+  G4double cross = dataSB[Z]->Value(x,y)*invb2*millibarn/bremFactor;
+  
+  if(!isElectron) {
+    G4double invbeta1 = sqrt(invb2);
+    G4double e2 = kinEnergy - gammaEnergy;
+    if(e2 > 0.0) {
+      G4double invbeta2 = (e2 + particleMass)/sqrt(e2*(e2 + 2*particleMass));
+      G4double xxx = twopi*fine_structure_const*currentZ*(invbeta1 - invbeta2);
+      if(xxx < expnumlim) { cross = 0.0; }
+      else { cross *= exp(xxx); }
+    } else {
+      cross = 0.0;
+    }
+  }
+  
+  return cross;
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
+
+void 
+G4SeltzerBergerModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp, 
+					const G4MaterialCutsCouple* couple,
+					const G4DynamicParticle* dp,
+					G4double cutEnergy,
+					G4double maxEnergy)
+{
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+#else
+   return;
+#endif
+  G4double kineticEnergy = dp->GetKineticEnergy();
+  G4double cut  = std::min(cutEnergy, kineticEnergy);
+  G4double emax = std::min(maxEnergy, kineticEnergy);
+  if(cut >= emax) { return; }
+
+  SetupForMaterial(particle, couple->GetMaterial(), kineticEnergy);
+
+  const G4Element* elm = 
+    SelectRandomAtom(couple,particle,kineticEnergy,cut,emax);
+  SetCurrentElement(elm->GetZ());
+  G4int Z = G4int(currentZ);
+
+  totalEnergy = kineticEnergy + particleMass;
+  densityCorr = densityFactor*totalEnergy*totalEnergy;
+  G4double totMomentum = sqrt(kineticEnergy*(totalEnergy + electron_mass_c2));
+  /*
+  G4cout << "G4SeltzerBergerModel::SampleSecondaries E(MeV)= " 
+	 << kineticEnergy/MeV
+	 << " Z= " << Z << " cut(MeV)= " << cut/MeV 
+	 << " emax(MeV)= " << emax/MeV << " corr= " << densityCorr << G4endl;
+  */
+  G4double xmin = log(cut*cut + densityCorr);
+  G4double xmax = log(emax*emax  + densityCorr);
+  G4double y = log(kineticEnergy/MeV);
+
+  G4double gammaEnergy, v; 
+
+  // majoranta
+  G4double x0 = cut/kineticEnergy;
+  G4double vmax = dataSB[Z]->Value(x0, y)*1.02;
+  //  G4double invbeta1 = 0;
+
+  const G4double epeaklimit= 300*MeV; 
+  const G4double elowlimit = 10*keV; 
+
+  // majoranta corrected for e-
+  if(isElectron && x0 < 0.97 && 
+     ((kineticEnergy > epeaklimit) || (kineticEnergy < elowlimit))) {
+    G4double ylim = std::min(ylimit[Z],1.1*dataSB[Z]->Value(0.97, y)); 
+    if(ylim > vmax) { vmax = ylim; }
+  }
+  if(x0 < 0.05) { vmax *= 1.2; }
+
+  //G4cout<<"y= "<<y<<" xmin= "<<xmin<<" xmax= "<<xmax<<" vmax= "<<vmax<<G4endl;
+  //  G4int ncount = 0;
+  do {
+    //++ncount;
+    G4double x = exp(xmin + G4UniformRand()*(xmax - xmin)) - densityCorr;
+    if(x < 0.0) { x = 0.0; }
+    gammaEnergy = sqrt(x);
+    G4double x1 = gammaEnergy/kineticEnergy;
+    v = dataSB[Z]->Value(x1, y);
+
+    // correction for positrons        
+    if(!isElectron) {
+      G4double e1 = kineticEnergy - cut;
+      G4double invbeta1 = (e1 + particleMass)/sqrt(e1*(e1 + 2*particleMass));
+      G4double e2 = kineticEnergy - gammaEnergy;
+      G4double invbeta2 = (e2 + particleMass)/sqrt(e2*(e2 + 2*particleMass));
+      G4double xxx = twopi*fine_structure_const*currentZ*(invbeta1 - invbeta2); 
+
+      if(xxx < expnumlim) { v = 0.0; }
+      else { v *= exp(xxx); }
+    }
+   
+    if (v > 1.05*vmax && nwarn < 20) {
+      ++nwarn;
+      G4cout << "### G4SeltzerBergerModel Warning: Majoranta exceeded! "
+	     << v << " > " << vmax << " by " << v/vmax
+	     << " Egamma(MeV)= " << gammaEnergy
+	     << " Ee(MeV)= " << kineticEnergy
+	     << " Z= " << Z << "  " << particle->GetParticleName()
+	//<< " ncount= " << ncount
+	     << G4endl;
+     
+      if ( 20 == nwarn ) {
+	G4cout << "### G4SeltzerBergerModel Warnings will not be printed anymore"
+	       << G4endl;
+      }
+    }
+  } while (v < vmax*G4UniformRand());
+
+  //
+  // angles of the emitted gamma. ( Z - axis along the parent particle)
+  // use general interface
+  //
+
+  G4ThreeVector gammaDirection = 
+    GetAngularDistribution()->SampleDirection(dp, totalEnergy-gammaEnergy,
+					      Z, couple->GetMaterial());
+
+  // create G4DynamicParticle object for the Gamma
+  G4DynamicParticle* gamma = 
+    new G4DynamicParticle(theGamma,gammaDirection,gammaEnergy);
+  vdp->push_back(gamma);
+  
+  G4ThreeVector direction = (totMomentum*dp->GetMomentumDirection()
+			     - gammaEnergy*gammaDirection).unit();
+
+  /*
+  G4cout << "### G4SBModel: v= "
+	 << " Eg(MeV)= " << gammaEnergy
+	 << " Ee(MeV)= " << kineticEnergy
+	 << " DirE " << direction << " DirG " << gammaDirection
+	 << G4endl;
+  */
+  // energy of primary
+  G4double finalE = kineticEnergy - gammaEnergy;
+
+  // stop tracking and create new secondary instead of primary
+  if(gammaEnergy > SecondaryThreshold()) {
+    fParticleChange->ProposeTrackStatus(fStopAndKill);
+    fParticleChange->SetProposedKineticEnergy(0.0);
+    G4DynamicParticle* el = 
+      new G4DynamicParticle(const_cast<G4ParticleDefinition*>(particle),
+			    direction, finalE);
+    vdp->push_back(el);
+
+    // continue tracking
+  } else {
+    fParticleChange->SetProposedMomentumDirection(direction);
+    fParticleChange->SetProposedKineticEnergy(finalE);
+  }
+}
+
+//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
+
+
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc	2013-05-24 07:21:23.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc	2014-01-06 13:01:38.206937276 -0600
@@ -439,15 +439,30 @@ G4double G4UrbanMscModel95::ComputeTrueP
 			     G4double& currentMinimalStep)
 {
   tPathLength = currentMinimalStep;
-  const G4DynamicParticle* dp = track.GetDynamicParticle();
   
   G4StepPoint* sp = track.GetStep()->GetPreStepPoint();
   G4StepStatus stepStatus = sp->GetStepStatus();
   couple = track.GetMaterialCutsCouple();
   SetCurrentCouple(couple); 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+  const G4DynamicParticle* dp = track.GetDynamicParticle();
   currentMaterialIndex = couple->GetIndex();
   currentKinEnergy = dp->GetKineticEnergy();
   currentRange = GetRange(particle,currentKinEnergy,couple);
+#else
+  // The cuda version does not set up the materials couple
+  // in the track, so it fakes it.
+  currentMaterialIndex = 1;
+  currentKinEnergy = 100.0;
+  // currentRange = GetRange(currentKinEnergy);
+   {
+      double kinEnergy = currentKinEnergy;
+      G4double dedx = 2.0*MeV*cm2/g;
+      G4double density = 5.16797e+19; // for electron
+      G4double localrange = kinEnergy/(dedx*density);
+      currentRange = localrange;
+   }
+#endif
   lambda0 = GetTransportMeanFreePath(particle,currentKinEnergy);
   if(tPathLength > currentRange) { tPathLength = currentRange; }
 
@@ -588,8 +603,12 @@ G4double G4UrbanMscModel95::ComputeTrueP
     {
       // compute presafety again if presafety <= 0 and no boundary
       // i.e. when it is needed for optimization purposes
+#ifdef NO_BACKPORT_CUDA_REMOVALS
       if((stepStatus != fGeomBoundary) && (presafety < tlimitminfix)) 
 	presafety = ComputeSafety(sp->GetPosition(),tPathLength); 
+#else
+      // @@ dwjang : will implement this part later
+#endif
       /*
       G4cout << "presafety= " << presafety
 	     << " firstStep= " << firstStep
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/include/G4VEmProcess.hh geant4.9.6.p02/source/processes/electromagnetic/utils/include/G4VEmProcess.hh
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/include/G4VEmProcess.hh	2013-05-24 07:21:24.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/include/G4VEmProcess.hh	2014-01-06 13:05:37.491798564 -0600
@@ -425,6 +425,7 @@ inline G4double G4VEmProcess::GetElectro
 inline void G4VEmProcess::DefineMaterial(const G4MaterialCutsCouple* couple)
 {
   if(couple != currentCouple) {
+    G4cout<<"G4VEmProcess.cc: currentCouple reset to "<< couple << G4endl;
     currentCouple   = couple;
     currentMaterial = couple->GetMaterial();
     baseMaterial = currentMaterial->GetBaseMaterial();
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh geant4.9.6.p02/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh	2013-05-24 07:21:24.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh	2014-01-06 13:18:41.963558989 -0600
@@ -723,7 +723,21 @@ inline G4double G4VEnergyLossProcess::Sc
 
 inline G4double G4VEnergyLossProcess::GetLambdaForScaledEnergy(G4double e)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.hh: e="<< e <<" fFactor="<< fFactor
+       <<" lambda(e)="<< ((*theLambdaTable)[basedCoupleIndex])->Value(e)
+       <<" - basedCoupleIndex="<< basedCoupleIndex << G4endl;
+#endif
   return fFactor*((*theLambdaTable)[basedCoupleIndex])->Value(e);
+#else
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.hh: e="<< e <<" fFactor="<< fFactor
+       <<" lambda(e)="<< ((*theLambdaTable)[1])->Value(e)
+       <<" - basedCoupleIndex(hardcoded)="<< 1 << G4endl;
+#endif
+  return fFactor*((*theLambdaTable)[1])->Value(e);
+#endif // NO_BACKPORT_CUDA_REMOVALS
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
@@ -821,6 +835,7 @@ G4VEnergyLossProcess::GetLambda(G4double
 
 inline void G4VEnergyLossProcess::ComputeLambdaForScaledEnergy(G4double e)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   mfpKinEnergy  = theEnergyOfCrossSectionMax[currentCoupleIndex];
   if (e <= mfpKinEnergy) {
     preStepLambda = GetLambdaForScaledEnergy(e);
@@ -838,6 +853,26 @@ inline void G4VEnergyLossProcess::Comput
       preStepLambda = fFactor*theCrossSectionMax[currentCoupleIndex];
     }
   }
+#else
+   // We dont really have couple information ...
+   mfpKinEnergy = 0.00713103;
+	if (e <= mfpKinEnergy) {
+		preStepLambda = GetLambdaForScaledEnergy(e);
+	} else {
+		G4double e1 = e * lambdaFactor;
+		if (e1 > mfpKinEnergy) {
+			preStepLambda = GetLambdaForScaledEnergy(e);
+			G4double preStepLambda1 = GetLambdaForScaledEnergy(e1);
+			if (preStepLambda1 > preStepLambda) {
+				mfpKinEnergy = e1;
+				preStepLambda = preStepLambda1;
+			}
+		} else {
+			//      preStepLambda = fFactor*theCrossSectionMax[currentCoupleIndex];
+			preStepLambda = 3.4635;
+		}
+	}
+#endif
 }
 
 // ======== Get/Set inline methods used at initialisation ================
@@ -965,6 +1000,9 @@ inline void G4VEnergyLossProcess::SetLam
 
 void G4VEnergyLossProcess::SetStepFunction(G4double v1, G4double v2)
 {
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProc.h: SetStepFunction called: currentCouple=0"<< G4endl;
+#endif
   dRoverRange = v1;
   finalRange = v2;
   if (dRoverRange > 0.999) { dRoverRange = 1.0; }
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4EmCalculator.cc geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4EmCalculator.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4EmCalculator.cc	2013-05-24 07:21:25.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4EmCalculator.cc	2014-01-06 13:05:37.509797802 -0600
@@ -967,6 +967,9 @@ G4bool G4EmCalculator::UpdateCouple(cons
   currentMaterialName = material->GetName();
   for (G4int i=0; i<nLocalMaterials; ++i) {
     if(material == localMaterials[i] && cut == localCuts[i]) {
+#ifdef GPUDEBUG
+      G4cout<<"G4EmCalculator.cc: Resetting currentCouple to "<< localCouples[i] << G4endl;
+#endif
       currentCouple = localCouples[i];
       currentCoupleIndex = currentCouple->GetIndex();
       currentCut = cut;
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VEmModel.cc geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VEmModel.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VEmModel.cc	2013-05-24 07:21:25.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VEmModel.cc	2014-01-06 12:56:51.003106191 -0600
@@ -219,20 +219,20 @@ const G4Element* G4VEmModel::SelectRando
 					      G4double tcut,
 					      G4double tmax)
 {
-  const G4ElementVector* theElementVector = material->GetElementVector();
-  G4int n = material->GetNumberOfElements() - 1;
-  fCurrentElement = (*theElementVector)[n];
-  if (n > 0) {
-    G4double x = G4UniformRand()*
-                 G4VEmModel::CrossSectionPerVolume(material,pd,kinEnergy,tcut,tmax);
-    for(G4int i=0; i<n; ++i) {
-      if (x <= xsec[i]) {
-	fCurrentElement = (*theElementVector)[i];
-	break;
+   const G4ElementVector* theElementVector = material->GetElementVector();
+   G4int n = material->GetNumberOfElements() - 1;
+   fCurrentElement = (*theElementVector)[n];
+   if (n > 0) {
+      G4double x = G4UniformRand()*
+      G4VEmModel::CrossSectionPerVolume(material,pd,kinEnergy,tcut,tmax);
+      for(G4int i=0; i<n; ++i) {
+         if (x <= xsec[i]) {
+            fCurrentElement = (*theElementVector)[i];
+            break;
+         }
       }
-    }
-  }
-  return fCurrentElement;
+   }
+   return fCurrentElement;
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc	2013-05-24 07:21:25.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc	2014-01-06 13:56:17.317968527 -0600
@@ -151,6 +151,10 @@
 #include "G4EmConfigurator.hh"
 #include "G4VAtomDeexcitation.hh"
 #include "G4EmBiasingManager.hh"
+#ifdef GPUPLOTS
+  #include "G4dataBuffer.hh"
+#endif
+
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
 
@@ -958,6 +962,8 @@ G4double G4VEnergyLossProcess::PostStepG
 
   if(!currentModel->IsActive(preStepScaledEnergy)) { return x; }
 
+   // dwjang : model selection checks whether this model is applicable in the given energy range.
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // change effective charge of an ion on fly
   if(isIon) {
     G4double q2 = currentModel->ChargeSquareRatio(track);
@@ -967,12 +973,15 @@ G4double G4VEnergyLossProcess::PostStepG
       reduceFactor = 1.0/(fFactor*massRatio);
     }
   }
+#endif
   //  if(particle->GetPDGMass() > 0.9*GeV)
   //G4cout << "q2= " << chargeSqRatio << " massRatio= " << massRatio << G4endl; 
   // initialisation for sampling of the interaction length 
   //if(previousStepSize <= 0.0) { theNumberOfInteractionLengthLeft = -1.0; }
   //if(theNumberOfInteractionLengthLeft < 0.0) { mfpKinEnergy = DBL_MAX; }
 
+   // dwjang : not considering bias at this moment
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // forced biasing only for primary particles
   if(biasManager) {
     if(0 == track.GetParentID()) {
@@ -981,6 +990,7 @@ G4double G4VEnergyLossProcess::PostStepG
       }
     }
   }
+#endif
 
   // compute mean free path
   if(preStepScaledEnergy < mfpKinEnergy) {
@@ -1016,19 +1026,37 @@ G4double G4VEnergyLossProcess::PostStepG
     currentInteractionLength = 1.0/preStepLambda;
     x = theNumberOfInteractionLengthLeft * currentInteractionLength;
 
-#ifdef G4VERBOSE
-    if (verboseLevel>2){
+#ifdef GPUPLOTS
+    G4dataBuffer& g4buffer = G4dataBuffer::getInstance();
+    if( this->GetProcessName() == "eBrem" ) {
+      g4buffer.getBuffer("hbremPreStepLambda").push_back(preStepLambda);
+      g4buffer.getBuffer("hbremPreStepScaledEnergy").push_back(preStepScaledEnergy);
+      g4buffer.getBuffer("hbremNbOfIntLengthLeft").push_back(theNumberOfInteractionLengthLeft);
+    }
+    else if( this->GetProcessName() == "eIoni" ) {
+      g4buffer.getBuffer("hioniPreStepLambda").push_back(preStepLambda);
+      g4buffer.getBuffer("hioniPreStepScaledEnergy").push_back(preStepScaledEnergy);
+      g4buffer.getBuffer("hioniNbOfIntLengthLeft").push_back(theNumberOfInteractionLengthLeft);
+      g4buffer.getBuffer("hioniMassRatio").push_back(massRatio);
+    }
+    else {
+      G4cout<<" G4VEnergyLossProcess.cc: "<< this->GetProcessName() << G4endl;
+    }
+#endif
+
+    if(verboseLevel>2) {
     //  if(particle->GetPDGMass() > 0.9*GeV){
       G4cout << "G4VEnergyLossProcess::PostStepGetPhysicalInteractionLength ";
       G4cout << "[ " << GetProcessName() << "]" << G4endl; 
       G4cout << " for " << track.GetDefinition()->GetParticleName() 
              << " in Material  " <<  currentMaterial->GetName()
 	     << " Ekin(MeV)= " << preStepKinEnergy/MeV 
-	     <<G4endl;
+	     << G4endl;
       G4cout << "MeanFreePath = " << currentInteractionLength/cm << "[cm]" 
 	     << "InteractionLength= " << x/cm <<"[cm] " <<G4endl;
+      G4cout<<"G4VEnergyLossProc: "<< preStepLambda <<' '<< theNumberOfInteractionLengthLeft
+	    <<' '<< preStepScaledEnergy << G4endl;
     }
-#endif
   }
   return x;
 }
@@ -1091,15 +1119,36 @@ G4VParticleChange* G4VEnergyLossProcess:
 
   // Short step
   eloss = GetDEDXForScaledEnergy(preStepScaledEnergy)*length;
+#ifdef GPUPLOTS
+  G4dataBuffer& g4buffer = G4dataBuffer::getInstance();
+  g4buffer.getBuffer("hioniDedxForScaledEnergyTimesLength").push_back(eloss);
+#endif
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.cc::AlongStepDoIt: preStepScaledE="<< preStepScaledEnergy
+	<<" length="<< length << G4endl;
+#endif
 
   // Long step
-  if(eloss > preStepKinEnergy*linLossLimit) {
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.cc: Eloss="<< eloss
+	   <<" preStepKinE * linLossLimit="<< preStepKinEnergy*linLossLimit
+	   <<" - Eloss required to be larger for ElossFromKinE-ScaledE calculation!"
+	   << G4endl;
+#endif
+   if(eloss > preStepKinEnergy*linLossLimit) {
 
     //G4double x = GetScaledRangeForScaledEnergy(preStepScaledEnergy) 
     //  - length/reduceFactor;
     G4double x = (fRange - length)/reduceFactor;
     eloss = preStepKinEnergy - ScaledKinEnergyForLoss(x)/massRatio;
-   
+#ifdef GPUDEBUG
+  G4cout<<" fRange="<< fRange <<" length="<< length <<" reduceFactor="<< reduceFactor
+	   <<" x="<< x <<" commentedX="<< (fRange - length/reduceFactor)
+	   <<" Eloss="<< eloss << G4endl;
+#endif
+#ifdef GPUPLOTS
+    g4buffer.getBuffer("hioniElossFromKinEnergyMinusScaledEnergyForLoss").push_back(eloss);
+#endif
     /*
     if(-1 < verboseLevel) 
       G4cout << "Long STEP: rPre(mm)= " 
@@ -1169,6 +1218,12 @@ G4VParticleChange* G4VEnergyLossProcess:
  	eloss -= GetSubDEDXForScaledEnergy(preStepScaledEnergy)*length;
 	esec = SampleSubCutSecondaries(scTracks, step, 
 				       currentModel,currentCoupleIndex);
+#ifdef GPUDEBUG
+  G4cout<<" G4VEneLossProc.cc: subcut sampling (not implemented in GPU): esec="<< esec
+	   <<" cut="<< cut
+	   <<" Eloss="<< eloss << G4endl;
+#endif
+
 	// add bremsstrahlung sampling
 	/*
 	if(nProcesses > 0) {
@@ -1196,6 +1251,13 @@ G4VParticleChange* G4VEnergyLossProcess:
   // Sample fluctuations
   if (lossFluctuationFlag) {
     G4VEmFluctuationModel* fluc = currentModel->GetModelOfFluctuations();
+#ifdef GPUDEBUG
+    G4cout<<"G4VEneLossProc.cc: fluc(T/F)="<< fluc <<" Eloss="<< eloss
+	     <<" esec="<< esec <<" and lowestKinE="<< lowestKinEnergy
+	     <<" --> sum="<< (eloss + esec + lowestKinEnergy)
+	     <<" vs. preStepKinE="<< preStepKinEnergy << G4endl;
+    G4cout<<"G4VEneLossProc.cc: If above sum < preStepKinE - then sample fluctuations will be calculated\n";
+#endif
     if(fluc && 
       (eloss + esec + lowestKinEnergy) < preStepKinEnergy) {
 
@@ -1204,9 +1266,15 @@ G4VParticleChange* G4VEnergyLossProcess:
       G4double emean = eloss;
       eloss = fluc->SampleFluctuations(currentMaterial,dynParticle,
 				       tmax,length,emean);
-      /*                            
-      if(-1 < verboseLevel) 
-      G4cout << "After fluct: eloss(MeV)= " << eloss/MeV
+#ifdef GPUDEBUG
+    G4cout<<"G4VEneLossProc.cc: tmax="<< tmax
+	     <<" emean="<< emean <<" Eloss=" << eloss << G4endl;
+#endif
+#ifdef GPUPLOTS
+      g4buffer.getBuffer("hioniElossFromSampleFluctuations").push_back(eloss);
+#endif
+      /*
+      G4cout << "G4VEnergyLossProcess.cc::AlongStepDoIt: After fluct: eloss(MeV)= " << eloss/MeV
              << " fluc= " << (eloss-eloss0)/MeV
              << " ChargeSqRatio= " << chargeSqRatio
              << " massRatio= " << massRatio
@@ -1240,6 +1308,11 @@ G4VParticleChange* G4VEnergyLossProcess:
       esec += esecfluo;
       eloss = 0.0; 
     } 
+#ifdef GPUDEBUG
+    G4cout<<"G4VEneLossProc.cc: Deexcitation (not implemented in GPU): esecfluo="<< esecfluo
+	     <<" de="<< de <<" esec="<< esec
+	     <<" Eloss=" << eloss << G4endl;
+#endif
     /*    
     if(esecfluo > 0.0) {
       G4cout << "### 2: E(keV)= " << preStepKinEnergy/keV
@@ -1249,11 +1322,11 @@ G4VParticleChange* G4VEnergyLossProcess:
 	     << " Eloss(keV)= " << eloss/keV 
 	     << G4endl; 
     } 
-    */   
+    */
   }
   if(scTracks.size() > 0) { FillSecondariesAlongStep(eloss, weight); }
 
-  // Energy balanse
+  // Energy balance
   G4double finalT = preStepKinEnergy - eloss - esec;
   if (finalT <= lowestKinEnergy) {
     eloss += finalT;
@@ -1268,6 +1341,12 @@ G4VParticleChange* G4VEnergyLossProcess:
   fParticleChange.SetProposedKineticEnergy(finalT);
   fParticleChange.ProposeLocalEnergyDeposit(eloss);
 
+#ifdef GPUDEBUG
+  G4cout<<"G4VEneLossProc.cc: finalT="<< finalT <<" Eloss="<< eloss << G4endl;
+#endif
+#ifdef GPUPLOTS
+  g4buffer.getBuffer("hioniEloss").push_back(eloss);
+#endif
   if(1 < verboseLevel) {
     G4double del = finalT + eloss + esec - preStepKinEnergy;
     G4cout << "Final value eloss(MeV)= " << eloss/MeV
@@ -1278,7 +1357,7 @@ G4VParticleChange* G4VEnergyLossProcess:
            << "  status= " << track.GetTrackStatus()
            << G4endl;
   }
-  
+
   return &fParticleChange;
 }
 
@@ -1327,6 +1406,7 @@ G4VEnergyLossProcess::SampleSubCutSecond
   if(cut <= subcut) { return esec; }
 
   const G4Track* track = step.GetTrack();
+
   const G4DynamicParticle* dp = track->GetDynamicParticle();
   G4double e = dp->GetKineticEnergy()*massRatio;
   G4double cross = (*theDensityFactor)[idx]*chargeSqRatio
@@ -1467,13 +1547,26 @@ G4VParticleChange* G4VEnergyLossProcess:
   }
 
   const G4DynamicParticle* dynParticle = track.GetDynamicParticle();
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   G4double tcut = (*theCuts)[currentCoupleIndex];
+#else
+   // dwjang : weight = 1, tcut = 0.00099 MeV
+   G4double tcut = 0.00099;  
+#endif
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // sample secondaries
   secParticles.clear();
-  //G4cout << "Energy of primary: " << dynParticle->GetKineticEnergy()/MeV<<G4endl;
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLoss.cc: Energy of primary: " << dynParticle->GetKineticEnergy()/MeV<<G4endl;
+  G4cout<<"G4VEnergyLoss.cc: calling SampleSecondaries with currentCouple="<< currentCouple << G4endl;
+#endif
   currentModel->SampleSecondaries(&secParticles, currentCouple, dynParticle, tcut);
 
+#ifdef GPUDEBUG
+  G4cout<<"# secondaries: "<< secParticles.size() << G4endl;
+#endif
+
   // bremsstrahlung splitting or Russian roulette  
   if(biasManager) {
     if(biasManager->SecondaryBiasingRegion(currentCoupleIndex)) {
@@ -1489,7 +1582,7 @@ G4VParticleChange* G4VEnergyLossProcess:
       }
     }
   }
-
+   
   // save secondaries
   G4int num = secParticles.size();
   if(num > 0) {
@@ -1508,6 +1601,10 @@ G4VParticleChange* G4VEnergyLossProcess:
       }
     }
   }
+#else
+   secParticles.clear();
+   currentModel->SampleSecondaries(&secParticles, currentCouple, dynParticle, tcut);
+#endif
 
   if(0.0 == fParticleChange.GetProposedKineticEnergy() &&
      fAlive == fParticleChange.GetTrackStatus()) {
@@ -1737,6 +1834,11 @@ G4double G4VEnergyLossProcess::CrossSect
   if(theLambdaTable) {
     cross = (*theDensityFactor)[currentCoupleIndex]*
       ((*theLambdaTable)[basedCoupleIndex])->Value(kineticEnergy);
+#ifdef GPUDEBUG
+    G4cout<<" G4VEnergyLossProcess.cc::xSecPerVolume: "<< kineticEnergy
+	  <<' '<< (*theDensityFactor)[currentCoupleIndex]
+	  <<' '<< ((*theLambdaTable)[basedCoupleIndex])->Value(kineticEnergy) << G4endl;
+#endif
   } else {
     SelectModel(kineticEnergy);
     cross = currentModel->CrossSectionPerVolume(currentMaterial,
diff -rupN geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc
--- geant4.9.6.p02-orig/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc	2013-05-24 07:21:25.000000000 -0500
+++ geant4.9.6.p02/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc	2014-01-06 12:56:51.026105215 -0600
@@ -354,17 +354,23 @@ G4double G4VMultipleScattering::AlongSte
   *selection = NotCandidateForSelection;
   physStepLimit = gPathLength = tPathLength = currentMinimalStep;
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   G4double ekin = track.GetKineticEnergy();
   // isIon flag is used only to select a model
   if(isIon) { 
     ekin *= proton_mass_c2/track.GetParticleDefinition()->GetPDGMass(); 
   }
-  
+
   // select new model
   if(1 < numberOfModels) {
     currentModel = static_cast<G4VMscModel*>(
       SelectModel(ekin,track.GetMaterialCutsCouple()->GetIndex()));
   }
+#else
+   G4double ekin = 100.;
+   currentModel = static_cast<G4VMscModel*>(modelManager->GetModel(0));
+#endif
+
 
   // step limit
   if(currentModel->IsActive(ekin) && gPathLength >= geomMin 
diff -rupN geant4.9.6.p02-orig/source/run/src/G4PhysicsListHelper.cc geant4.9.6.p02/source/run/src/G4PhysicsListHelper.cc
--- geant4.9.6.p02-orig/source/run/src/G4PhysicsListHelper.cc	2013-05-24 07:21:11.000000000 -0500
+++ geant4.9.6.p02/source/run/src/G4PhysicsListHelper.cc	2014-01-06 13:05:37.534796742 -0600
@@ -110,6 +110,7 @@ void G4PhysicsListHelper::CheckParticleL
   while( (*theParticleIterator)() ){
     G4ParticleDefinition* particle = theParticleIterator->value();
     G4String name = particle->GetParticleName();
+    G4cout<<"particle="<<name<<G4endl;
     // check if any EM process exists
     if (!isEmProc) {
       G4ProcessVector* list = particle->GetProcessManager()->GetProcessList();
diff -rupN geant4.9.6.p02-orig/source/track/include/G4Step.hh geant4.9.6.p02/source/track/include/G4Step.hh
--- geant4.9.6.p02-orig/source/track/include/G4Step.hh	2013-05-24 07:21:12.000000000 -0500
+++ geant4.9.6.p02/source/track/include/G4Step.hh	2014-01-06 13:05:37.549796106 -0600
@@ -201,26 +201,26 @@ class G4Step
 // Secondary buckets
 public:
   // secodaries in the current step
-   const std::vector<const G4Track*>* GetSecondaryInCurrentStep() const; 
+   const std::vector<const G4Track*>* GetSecondaryInCurrentStep() const;
 
-   // NOTE: Secondary bucket of the Step contains  
-   //       all secondaries during tracking the current track 
+   // NOTE: Secondary bucket of the Step contains
+   //       all secondaries during tracking the current track
    //       (i.e. NOT secondaries produced in the current step)
    // all following methods give same object (i.e. G4TrackVector  )
-   // but 2nd one will create bucket in addition  
+   // but 2nd one will create bucket in addition
    const G4TrackVector* GetSecondary() const ;
    G4TrackVector* GetfSecondary();
    G4TrackVector* NewSecondaryVector();
 
    // just delete secondary bucket
-   //  NOTE: G4Track objects inside the bucket are not deleted 
+   //  NOTE: G4Track objects inside the bucket are not deleted
    void DeleteSecondaryVector();
 
-   // Add secondary tracks to the bucket 
+   // Add secondary tracks to the bucket
    void SetSecondary( G4TrackVector* value);
 
-private: 
-   // Secondaty bucket implemented by using  std::vector of G4Track*   
+private:
+   // Secondaty bucket implemented by using  std::vector of G4Track*
    G4TrackVector* fSecondary;
 
    // number of secondaries which have been created by the last step
