Binary files geant4.9.6.p01-orig/source/._.DS_Store and geant4.9.6.p01-valid/source/._.DS_Store differ
Binary files geant4.9.6.p01-orig/source/.DS_Store and geant4.9.6.p01-valid/source/.DS_Store differ
diff -rupN geant4.9.6.p01-orig/source/externals/clhep/src/NonRandomEngine.cc geant4.9.6.p01-valid/source/externals/clhep/src/NonRandomEngine.cc
--- geant4.9.6.p01-orig/source/externals/clhep/src/NonRandomEngine.cc	2013-02-06 06:50:24.000000000 -0600
+++ geant4.9.6.p01-valid/source/externals/clhep/src/NonRandomEngine.cc	2013-12-09 11:13:57.856885938 -0600
@@ -18,6 +18,7 @@
 //
 //=========================================================================
 
+//#include "Validation/ValidationConfig.h"  // GL: adding GPU Validation config
 #include "CLHEP/Random/NonRandomEngine.h"
 #include "CLHEP/Random/engineIDulong.h"
 #include "CLHEP/Random/DoubConv.h"
@@ -52,7 +53,12 @@ void NonRandomEngine::setRandomSequence(
   assert (sequence.size() == (unsigned int)n);
   nInSeq = 0;
   sequenceHasBeenSet=true;
+#ifndef GPUDEBUG
+#warning NonRandomEngine: GPUDEBUG=undefined - Random numbers are OK
   nextHasBeenSet=false;
+#else
+#warning NonRandomEngine: GPUDEBUG=Defined - Random numbers hardcoded (fixed!)
+#endif
   return;
 }
 
@@ -77,7 +83,12 @@ double NonRandomEngine::flat() {
   }
 
   double a = nextRandom;
+#ifndef GPUDEBUG
+#warning NonRandomEngine.cc: GPUDEBUG is NOT defined! random numbers OK
   nextHasBeenSet = false;
+#else
+#warning NonRandomEngine.cc: GPUDEBUG is defined: 'random' numbers hardcoded (fixed!)
+#endif
 
   if (intervalHasBeenSet) {
     nextRandom += randomInterval;
diff -rupN geant4.9.6.p01-orig/source/global/management/include/G4dataBuffer.hh geant4.9.6.p01-valid/source/global/management/include/G4dataBuffer.hh
--- geant4.9.6.p01-orig/source/global/management/include/G4dataBuffer.hh	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p01-valid/source/global/management/include/G4dataBuffer.hh	2013-12-09 13:28:52.214541171 -0600
@@ -0,0 +1,64 @@
+//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
+//
+// File: G4dataBuffer.hh
+//
+// Purpose:
+//   Central class to centralize management of histograms and similar objects.
+//
+// This is how to use it:
+// 1. get a pointer:    G4dataBuffer* hmgr = G4dataBuffer::getInstance();
+// 2. book a histogram: TH1F* hist = hmgr->book1F("name",100,0.1);
+// 3. fill it (best):   hist->fill(value);
+// 4. also works:       hmgr->fill("name",value);
+//
+// Last method can also be called from any other place, by accessing
+// following steps 1 and 4.
+//
+// Note: make sure this class is destroyed at end of job, otherwise
+// histograms may not be saved.
+//
+// 20131209 - Guilherme Lima - Created
+//
+//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
+#ifndef _G4DATABUFFER_HH_
+#define _G4DATABUFFER_HH_
+
+#include "G4Types.hh"
+#include <string>
+#include <map>
+#include <vector>
+
+// Maps of data keyed by a string
+typedef std::map<std::string,std::vector<G4double> > DataMap;
+typedef std::map<std::string,std::vector<std::pair<G4double,G4double> > > Data2DMap;
+
+class G4dataBuffer {
+
+public:
+  static G4dataBuffer& getInstance() {
+    if( !_me ) _me = new G4dataBuffer();
+    return *_me;
+  }
+
+  void destroy();
+
+  std::vector<G4double>& getBuffer(const std::string& name);
+  std::vector< std::pair<G4double,G4double> >& getBuffer2D(const std::string& name);
+
+  void fill(std::string& name, float value);
+  void fill(std::string& name, float value, float val2);
+
+private:
+  // Constructor
+  G4dataBuffer();
+  // Destructor
+  ~G4dataBuffer();
+
+private:
+  // ***** Member data  *****
+  static G4dataBuffer* _me;  // singleton pointer
+  DataMap _map;
+  Data2DMap _map2D;
+};
+
+#endif // _G4DATABUFFER_HH_
diff -rupN geant4.9.6.p01-orig/source/global/management/sources.cmake geant4.9.6.p01-valid/source/global/management/sources.cmake
--- geant4.9.6.p01-orig/source/global/management/sources.cmake	2013-02-06 06:49:57.000000000 -0600
+++ geant4.9.6.p01-valid/source/global/management/sources.cmake	2013-12-09 12:34:25.109331690 -0600
@@ -36,6 +36,7 @@ GEANT4_DEFINE_MODULE(NAME G4globman
         G4ApplicationState.hh
         G4DataVector.hh
         G4DataVector.icc
+        G4dataBuffer.hh
         G4ErrorPropagatorData.hh
         G4ErrorPropagatorData.icc
         G4Evaluator.hh
@@ -92,6 +93,7 @@ GEANT4_DEFINE_MODULE(NAME G4globman
     SOURCES
         G4AllocatorPool.cc
         G4DataVector.cc
+        G4dataBuffer.cc
         G4ErrorPropagatorData.cc
         G4Exception.cc
         G4GeometryTolerance.cc
diff -rupN geant4.9.6.p01-orig/source/global/management/src/G4dataBuffer.cc geant4.9.6.p01-valid/source/global/management/src/G4dataBuffer.cc
--- geant4.9.6.p01-orig/source/global/management/src/G4dataBuffer.cc	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p01-valid/source/global/management/src/G4dataBuffer.cc	2013-12-09 13:35:40.102088240 -0600
@@ -0,0 +1,50 @@
+#include "G4dataBuffer.hh"
+
+using std::string;
+using std::vector;
+using std::pair;
+using std::map;
+
+G4dataBuffer* G4dataBuffer::_me = NULL;
+
+G4dataBuffer::G4dataBuffer() { }
+
+G4dataBuffer::~G4dataBuffer() {
+  this->destroy();
+}
+
+void G4dataBuffer::destroy() {
+  // first empty maps
+  _map.clear();
+  _map2D.clear();
+  // then singleton destroys itself
+  if(_me) delete _me;
+}
+
+
+std::vector<G4double>& G4dataBuffer::getBuffer(const std::string& name) {
+  DataMap::iterator iter = _map.find(name);
+  if( iter != _map.end() ) return iter->second;
+  else {
+    _map.insert( pair<string,vector<G4double> >(name,vector<double>()) );
+    return _map[name];
+  }
+}
+
+
+std::vector< std::pair<G4double,G4double> >& G4dataBuffer::getBuffer2D(const std::string& name) {
+  Data2DMap::iterator iter = _map2D.find(name);
+  if( iter != _map2D.end() ) return iter->second;
+  else {
+    _map2D.insert( pair<string,vector<pair<G4double,G4double> > >() );
+    return _map2D[name];
+  }
+}
+
+void G4dataBuffer::fill(string& name, float value) {
+  _map[name].push_back(value);
+}
+
+void G4dataBuffer::fill(string& name, float value, float val2) {
+  _map2D[name].push_back( pair<G4double,G4double>(value,val2) );
+}
diff -rupN geant4.9.6.p01-orig/source/materials/src/G4Material.cc geant4.9.6.p01-valid/source/materials/src/G4Material.cc
--- geant4.9.6.p01-orig/source/materials/src/G4Material.cc	2013-02-06 06:49:05.000000000 -0600
+++ geant4.9.6.p01-valid/source/materials/src/G4Material.cc	2013-11-12 14:29:54.757362164 -0600
@@ -126,6 +126,9 @@ G4Material::G4Material(const G4String& n
       else                          { fState = kStateGas; }
     }
 
+#ifdef GPUDEBUG
+  G4cout<<"G4Material constructor: calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
   ComputeDerivedQuantities();
 }
 
@@ -296,8 +299,12 @@ void G4Material::ComputeDerivedQuantitie
      VecNbOfAtomsPerVolume[i] = Avogadro*fDensity*fMassFractionVector[i]/Ai;
      TotNbOfAtomsPerVolume += VecNbOfAtomsPerVolume[i];
      TotNbOfElectPerVolume += VecNbOfAtomsPerVolume[i]*Zi;
+#ifdef GPUDEBUG
+     G4cout<<"G4Material: CompDerivedQuantities: "<< Zi <<' '<< Ai <<' '<< VecNbOfAtomsPerVolume[i]
+	   <<' '<< TotNbOfAtomsPerVolume <<' '<< TotNbOfElectPerVolume << G4endl;
+#endif
   }
-        
+
   ComputeRadiationLength();
   ComputeNuclearInterLength();
 
@@ -326,6 +333,9 @@ void G4Material::CopyPointersOfBaseMater
     VecNbOfAtomsPerVolume[i] = factor*v[i];
   }
   fRadlen = fBaseMaterial->GetRadlen()/factor;
+#ifdef GPUDEBUG
+  G4cout<<"G4Material::CopyPointersOfBaseMaterial: fRadLen="<< fRadlen <<" factor="<< factor << G4endl;
+#endif
   fNuclInterLen = fBaseMaterial->GetNuclearInterLength()/factor;
   if (fIonisation) { delete fIonisation; }
   fIonisation  = new G4IonisParamMat(this);
@@ -373,6 +383,9 @@ void G4Material::AddElement(G4Element* e
     }
 
     fMassOfMolecule = Amol/Avogadro;
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddElement(nAtoms): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -435,7 +448,10 @@ void G4Material::AddElement(G4Element* e
       fAtomsVector[i] = 
 	G4int(fMassFractionVector[i]*Amol/(*theElementVector)[i]->GetA()+0.5);
     }
-     
+
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddElement(fraction): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -527,6 +543,9 @@ void G4Material::AddMaterial(G4Material*
 	G4int(fMassFractionVector[i]*Amol/(*theElementVector)[i]->GetA()+0.5);
     }
      
+#ifdef GPUDEBUG
+    G4cout<<"G4Material::AddMaterial(fraction): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
     ComputeDerivedQuantities();
   }
 }
@@ -538,8 +557,17 @@ void G4Material::ComputeRadiationLength(
   G4double radinv = 0.0 ;
   for (size_t i=0;i<fNumberOfElements;++i) {
      radinv += VecNbOfAtomsPerVolume[i]*((*theElementVector)[i]->GetfRadTsai());
+#ifdef GPUDEBUG
+     G4cout<<"G4Material::ComputeRadiationLength: i="<< i <<" radinv="<< radinv
+	   <<", NbAtosPerVol="<< VecNbOfAtomsPerVolume[i]
+	   <<", Elem fRadTsai="<< ((*theElementVector)[i]->GetfRadTsai())
+	   << std::endl;
+#endif
   }
   fRadlen = (radinv <= 0.0 ? DBL_MAX : 1./radinv);
+#ifdef GPUDEBUG
+  G4cout<<"G4Material::ComputeRadiationLength: final fRadLen="<< fRadlen <<" radinv="<< radinv << G4endl;
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
@@ -670,6 +698,9 @@ const G4Material& G4Material::operator=(
 	  fMassFractionVector[i] = right.fMassFractionVector[i];
 	  fAtomsVector[i]        = right.fAtomsVector[i];
 	}
+#ifdef GPUDEBUG
+	G4cout<<"G4Material::operator=(): calling ComputeDerivedQuantities()..."<< G4endl;
+#endif
 	ComputeDerivedQuantities();
       }
       	   
diff -rupN geant4.9.6.p01-orig/source/persistency/gdml/src/G4GDMLRead.cc geant4.9.6.p01-valid/source/persistency/gdml/src/G4GDMLRead.cc
--- geant4.9.6.p01-orig/source/persistency/gdml/src/G4GDMLRead.cc	2013-02-06 06:51:56.000000000 -0600
+++ geant4.9.6.p01-valid/source/persistency/gdml/src/G4GDMLRead.cc	2013-02-07 09:45:54.000000000 -0600
@@ -288,7 +288,7 @@ void G4GDMLRead::Read(const G4String& fi
    xercesc::ErrorHandler* handler = new G4GDMLErrorHandler(!validate);
    xercesc::XercesDOMParser* parser = new xercesc::XercesDOMParser;
 
-   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Always);
+   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Never);
    parser->setValidationSchemaFullChecking(true);
    parser->setCreateEntityReferenceNodes(false); 
      // Entities will be automatically resolved by Xerces
diff -rupN geant4.9.6.p01-orig/source/persistency/gdml/src/G4GDMLRead.cc_1 geant4.9.6.p01-valid/source/persistency/gdml/src/G4GDMLRead.cc_1
--- geant4.9.6.p01-orig/source/persistency/gdml/src/G4GDMLRead.cc_1	1969-12-31 18:00:00.000000000 -0600
+++ geant4.9.6.p01-valid/source/persistency/gdml/src/G4GDMLRead.cc_1	2013-02-07 09:43:50.000000000 -0600
@@ -0,0 +1,365 @@
+//
+// ********************************************************************
+// * License and Disclaimer                                           *
+// *                                                                  *
+// * The  Geant4 software  is  copyright of the Copyright Holders  of *
+// * the Geant4 Collaboration.  It is provided  under  the terms  and *
+// * conditions of the Geant4 Software License,  included in the file *
+// * LICENSE and available at  http://cern.ch/geant4/license .  These *
+// * include a list of copyright holders.                             *
+// *                                                                  *
+// * Neither the authors of this software system, nor their employing *
+// * institutes,nor the agencies providing financial support for this *
+// * work  make  any representation or  warranty, express or implied, *
+// * regarding  this  software system or assume any liability for its *
+// * use.  Please see the license in the file  LICENSE  and URL above *
+// * for the full disclaimer and the limitation of liability.         *
+// *                                                                  *
+// * This  code  implementation is the result of  the  scientific and *
+// * technical work of the GEANT4 collaboration.                      *
+// * By using,  copying,  modifying or  distributing the software (or *
+// * any work based  on the software)  you  agree  to acknowledge its *
+// * use  in  resulting  scientific  publications,  and indicate your *
+// * acceptance of all terms of the Geant4 Software license.          *
+// ********************************************************************
+//
+// $Id$
+//
+// class G4GDMLRead Implementation
+//
+// History:
+// - Created.                                  Zoltan Torzsok, November 2007
+// -------------------------------------------------------------------------
+
+#include "globals.hh"
+
+#include "G4GDMLRead.hh"
+
+#include "G4UnitsTable.hh"
+#include "G4Element.hh"
+#include "G4Material.hh"
+#include "G4SolidStore.hh"
+#include "G4LogicalVolumeStore.hh"
+#include "G4PhysicalVolumeStore.hh"
+
+G4GDMLRead::G4GDMLRead()
+  : validate(true), check(false), inLoop(0), loopCount(0)
+{
+   G4UnitDefinition::BuildUnitsTable();
+}
+
+G4GDMLRead::~G4GDMLRead()
+{
+}
+
+G4String G4GDMLRead::Transcode(const XMLCh* const toTranscode)
+{
+   char* char_str = xercesc::XMLString::transcode(toTranscode);
+   G4String my_str(char_str);
+   xercesc::XMLString::release(&char_str);
+   return my_str;
+}
+
+void G4GDMLRead::OverlapCheck(G4bool flag)
+{
+   check = flag;
+}
+
+G4String G4GDMLRead::GenerateName(const G4String& nameIn, G4bool strip)
+{
+   G4String nameOut(nameIn);
+
+   if (inLoop>0)
+   {
+     nameOut = eval.SolveBrackets(nameOut);
+//     std::stringstream stream;
+//     stream << "0x" << loopCount;
+//     nameOut = nameOut + stream.str();
+   }
+   if (strip) { StripName(nameOut); }
+
+   return nameOut;
+}
+
+void G4GDMLRead::GeneratePhysvolName(const G4String& nameIn,
+                                     G4VPhysicalVolume* physvol)
+{
+   G4String nameOut(nameIn);
+
+   if (nameIn.empty())
+   {
+     std::stringstream stream;
+     stream << physvol->GetLogicalVolume()->GetName() << "_PV";
+     nameOut = stream.str();
+   }
+   nameOut = eval.SolveBrackets(nameOut);
+
+   physvol->SetName(nameOut);
+}
+
+G4String G4GDMLRead::Strip(const G4String& name) const
+{
+  G4String sname(name);
+  return sname.remove(sname.find("0x"));
+}
+
+void G4GDMLRead::StripName(G4String& name) const
+{
+  name.remove(name.find("0x"));
+}
+
+void G4GDMLRead::StripNames() const
+{
+  // Strips off names of volumes, solids elements and materials from possible
+  // reference pointers or IDs attached to their original identifiers.
+
+  G4PhysicalVolumeStore* pvols = G4PhysicalVolumeStore::GetInstance();
+  G4LogicalVolumeStore* lvols = G4LogicalVolumeStore::GetInstance();
+  G4SolidStore* solids = G4SolidStore::GetInstance();
+  const G4ElementTable* elements = G4Element::GetElementTable();
+  const G4MaterialTable* materials = G4Material::GetMaterialTable();
+
+  G4cout << "Stripping off GDML names of materials, solids and volumes ..."
+         << G4endl;
+
+  G4String sname;
+  register size_t i;
+
+  // Solids...
+  //
+  for (i=0; i<solids->size(); i++)
+  {
+    G4VSolid* psol = (*solids)[i];
+    sname = psol->GetName();
+    StripName(sname);
+    psol->SetName(sname);
+  }
+
+  // Logical volumes...
+  //
+  for (i=0; i<lvols->size(); i++)
+  {
+    G4LogicalVolume* lvol = (*lvols)[i];
+    sname = lvol->GetName();
+    StripName(sname);
+    lvol->SetName(sname);
+  }
+
+  // Physical volumes...
+  //
+  for (i=0; i<pvols->size(); i++)
+  {
+    G4VPhysicalVolume* pvol = (*pvols)[i];
+    sname = pvol->GetName();
+    StripName(sname);
+    pvol->SetName(sname);
+  }
+
+  // Materials...
+  //
+  for (i=0; i<materials->size(); i++)
+  {
+    G4Material* pmat = (*materials)[i];
+    sname = pmat->GetName();
+    StripName(sname);
+    pmat->SetName(sname);
+  }
+
+  // Elements...
+  //
+  for (i=0; i<elements->size(); i++)
+  {
+    G4Element* pelm = (*elements)[i];
+    sname = pelm->GetName();
+    StripName(sname);
+    pelm->SetName(sname);
+  }
+}
+
+void G4GDMLRead::LoopRead(const xercesc::DOMElement* const element,
+     void(G4GDMLRead::*func)(const xercesc::DOMElement* const))
+{
+   G4String var;
+   G4String from;
+   G4String to;
+   G4String step;
+
+   const xercesc::DOMNamedNodeMap* const attributes = element->getAttributes();
+   XMLSize_t attributeCount = attributes->getLength();
+
+   for (XMLSize_t attribute_index=0;
+        attribute_index<attributeCount;attribute_index++)
+   {
+      xercesc::DOMNode* attribute_node = attributes->item(attribute_index);
+
+      if (attribute_node->getNodeType() != xercesc::DOMNode::ATTRIBUTE_NODE)
+      { continue; }
+
+      const xercesc::DOMAttr* const attribute
+            = dynamic_cast<xercesc::DOMAttr*>(attribute_node);   
+      if (!attribute)
+      {
+        G4Exception("G4GDMLRead::LoopRead()", "InvalidRead",
+                    FatalException, "No attribute found!");
+        return;
+      }
+      const G4String attribute_name = Transcode(attribute->getName());
+      const G4String attribute_value = Transcode(attribute->getValue());
+
+      if (attribute_name=="for")  { var = attribute_value; }  else
+      if (attribute_name=="from") { from = attribute_value; } else
+      if (attribute_name=="to")   { to = attribute_value; }   else
+      if (attribute_name=="step") { step = attribute_value; }
+   }
+
+   if (var.empty())
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "No variable is determined for loop!");
+   }
+
+   if (!eval.IsVariable(var))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Variable is not defined in loop!");
+   }
+
+   G4int _var = eval.EvaluateInteger(var);
+   G4int _from = eval.EvaluateInteger(from);
+   G4int _to = eval.EvaluateInteger(to);
+   G4int _step = eval.EvaluateInteger(step);
+   
+   if (!from.empty()) { _var = _from; }
+
+   if (_from == _to)
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Empty loop!");
+   }
+   if ((_from < _to) && (_step <= 0))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Infinite loop!");
+   }
+   if ((_from > _to) && (_step >= 0))
+   {
+     G4Exception("G4GDMLRead::loopRead()", "InvalidRead",
+                 FatalException, "Infinite loop!");
+   }
+
+   inLoop++;
+
+   while (_var <= _to)
+   {
+      eval.SetVariable(var,_var);
+      (this->*func)(element);
+      _var += _step;
+      loopCount++;
+   }
+
+   inLoop--;
+   if (!inLoop) { loopCount = 0; }
+}
+
+void G4GDMLRead::ExtensionRead(const xercesc::DOMElement* const)
+{
+   G4String error_msg = "No handle to user-code for parsing extensions!";
+   G4Exception("G4GDMLRead::ExtensionRead()",
+               "NotImplemented", JustWarning, error_msg);
+}
+
+void G4GDMLRead::Read(const G4String& fileName,
+                            G4bool validation,
+                            G4bool isModule,
+                            G4bool strip)
+{
+   if (isModule)
+   {
+      G4cout << "G4GDML: Reading module '" << fileName << "'..." << G4endl;
+   }
+   else
+   {
+      G4cout << "G4GDML: Reading '" << fileName << "'..." << G4endl;
+   }
+
+   inLoop = 0;
+   validate = validation;
+
+   xercesc::ErrorHandler* handler = new G4GDMLErrorHandler(!validate);
+   xercesc::XercesDOMParser* parser = new xercesc::XercesDOMParser;
+
+   parser->setValidationScheme(xercesc::XercesDOMParser::Val_Always);
+   parser->setValidationSchemaFullChecking(true);
+   parser->setCreateEntityReferenceNodes(false); 
+     // Entities will be automatically resolved by Xerces
+
+   parser->setDoNamespaces(true);
+   parser->setDoSchema(true);
+   parser->setErrorHandler(handler);
+
+   try { parser->parse(fileName.c_str()); }
+   catch (const xercesc::XMLException &e)
+     { G4cout << "G4GDML: " << Transcode(e.getMessage()) << G4endl; }
+   catch (const xercesc::DOMException &e)
+     { G4cout << "G4GDML: " << Transcode(e.getMessage()) << G4endl; }
+
+   xercesc::DOMDocument* doc = parser->getDocument();
+
+   if (!doc)
+   {
+     G4String error_msg = "Unable to open document: " + fileName;
+     G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                 FatalException, error_msg);
+     return;
+   }
+   xercesc::DOMElement* element = doc->getDocumentElement();
+
+   if (!element)
+   {
+     G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                 FatalException, "Empty document!");
+     return;
+   }
+
+   for (xercesc::DOMNode* iter = element->getFirstChild();
+        iter != 0; iter = iter->getNextSibling())
+   {
+      if (iter->getNodeType() != xercesc::DOMNode::ELEMENT_NODE)  { continue; }
+
+      const xercesc::DOMElement* const child
+            = dynamic_cast<xercesc::DOMElement*>(iter);
+      if (!child)
+      {
+        G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                    FatalException, "No child found!");
+        return;
+      }
+      const G4String tag = Transcode(child->getTagName());
+
+      if (tag=="define")    { DefineRead(child);    } else
+      if (tag=="materials") { MaterialsRead(child); } else
+      if (tag=="solids")    { SolidsRead(child);    } else
+      if (tag=="setup")     { SetupRead(child);     } else
+      if (tag=="structure") { StructureRead(child); } else
+      if (tag=="extension") { ExtensionRead(child); }
+      else
+      {
+        G4String error_msg = "Unknown tag in gdml: " + tag;
+        G4Exception("G4GDMLRead::Read()", "InvalidRead",
+                    FatalException, error_msg);
+      }
+   }
+
+   delete parser;
+   delete handler;
+
+   if (isModule)
+   {
+      G4cout << "G4GDML: Reading module '" << fileName << "' done!" << G4endl;
+   }
+   else
+   {
+      G4cout << "G4GDML: Reading '" << fileName << "' done!" << G4endl;
+      if (strip)  { StripNames(); }
+   }
+}
diff -rupN geant4.9.6.p01-orig/source/processes/cuts/src/G4ProductionCutsTable.cc geant4.9.6.p01-valid/source/processes/cuts/src/G4ProductionCutsTable.cc
--- geant4.9.6.p01-orig/source/processes/cuts/src/G4ProductionCutsTable.cc	2013-02-06 06:51:54.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/cuts/src/G4ProductionCutsTable.cc	2013-10-30 12:26:46.282399223 -0500
@@ -162,6 +162,9 @@ void G4ProductionCutsTable::UpdateCouple
    if((*rItr)->IsInMassGeometry() || (*rItr)->IsInParallelGeometry())
    {
 
+     G4cout<<"G4ProductionCutsTable.cc: Updating material-cut-couple for region: "<< (*rItr)->GetName()
+	   <<" -- #mats="<< (*rItr)->GetNumberOfMaterials() << G4endl;
+
     G4ProductionCuts* fProductionCut = (*rItr)->GetProductionCuts();
     std::vector<G4Material*>::const_iterator mItr =
       (*rItr)->GetMaterialIterator();
@@ -174,10 +177,12 @@ void G4ProductionCutsTable::UpdateCouple
       G4MaterialCutsCouple* aCouple;
       for(CoupleTableIterator cItr=coupleTable.begin();
           cItr!=coupleTable.end();cItr++){
+	G4cout<<"G4ProductionCutsTable.cc: checking next coupleIterator: "<< (*cItr) << G4endl;
         if( (*cItr)->GetMaterial()==(*mItr)    && 
 	    (*cItr)->GetProductionCuts()==fProductionCut){ 
           coupleAlreadyDefined = true;
           aCouple = *cItr;
+	  G4cout<<"G4ProductionCutsTable.cc: couple already defined: material="<< (*mItr) <<" "<< (*mItr)->GetName() << G4endl;
           break;
         }
       }
@@ -185,6 +190,7 @@ void G4ProductionCutsTable::UpdateCouple
       // If this combination is new, cleate and register a couple
       if(!coupleAlreadyDefined){
         aCouple = new G4MaterialCutsCouple((*mItr),fProductionCut);
+	G4cout<<"G4ProductionCutsTable.cc: new couple created: "<< aCouple <<", material="<< (*mItr) <<" "<< (*mItr)->GetName() << G4endl;
         coupleTable.push_back(aCouple);
         aCouple->SetIndex(coupleTable.size()-1);
       }
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc
--- geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc	2013-02-06 06:50:29.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4eBremsstrahlungRelModel.cc	2013-11-12 14:34:59.717253122 -0600
@@ -148,6 +148,12 @@ void G4eBremsstrahlungRelModel::SetupFor
 {
   densityFactor = mat->GetElectronDensity()*fMigdalConstant;
   lpmEnergy = mat->GetRadlen()*fLPMconstant;
+#ifdef GPUDEBUG
+  G4cout<<"GPSeltzer::SetupForMaterial: fMigdalC="<< fMigdalConstant
+	<<", fLPM="<< fLPMconstant
+	<<", densityFac="<< densityFactor
+	<<", lpmEnergy="<< lpmEnergy << G4endl;
+#endif
 
   // Threshold for LPM effect (i.e. below which LPM hidden by density effect) 
   if (LPMFlag()) {
@@ -164,6 +170,15 @@ void G4eBremsstrahlungRelModel::SetupFor
   klpm=totalEnergy*totalEnergy/lpmEnergy;
   kp=sqrt(densityCorr);
     
+#ifdef GPUDEBUG
+  G4cout<<"GPSeltzer::SetupForMaterial: EneThreshLPM="<< energyThresholdLPM
+	<<", kinEne="<< kinEnergy
+	<<", totEne="<< totalEnergy
+	<<", densityCorr="<< densityCorr
+	<<", klpm="<< klpm
+	<<", kp="<< kp
+	<< G4endl;
+#endif
 }
 
 
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc
--- geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc	2013-02-06 06:50:29.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc	2013-12-05 18:08:28.044748576 -0600
@@ -189,6 +189,12 @@ G4double G4MollerBhabhaModel::CrossSecti
                                                  G4double maxEnergy)
 {
   G4double eDensity = material->GetElectronDensity();
+
+  G4cout<<" G4MollerBhabhaModel.cc::xSecPerVolume: "<< kinEnergy
+	<<' '<< eDensity
+	<<' '<< ComputeCrossSectionPerElectron(p,kinEnergy,cutEnergy,maxEnergy)
+	<< G4endl;
+
   return eDensity*ComputeCrossSectionPerElectron(p,kinEnergy,cutEnergy,maxEnergy);
   /*
   G4double Zeff     = eDensity/material->GetTotNbOfAtomsPerVolume();
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc
--- geant4.9.6.p01-orig/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc	2013-02-06 06:50:29.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc	2013-11-12 14:40:18.316593735 -0600
@@ -211,10 +211,16 @@ G4SeltzerBergerModel::SampleSecondaries(
 					G4double maxEnergy)
 {
   G4double kineticEnergy = dp->GetKineticEnergy();
+#ifdef GPUDEBUG
+  G4cout<<"G4Seltzer: vdp="<< vdp <<", couple="<< couple <<", dp="<< dp <<" cutEn="<< cutEnergy <<", kinE="<< kineticEnergy << G4endl;
+#endif
+
   G4double cut  = std::min(cutEnergy, kineticEnergy);
   G4double emax = std::min(maxEnergy, kineticEnergy);
   if(cut >= emax) { return; }
-
+#ifdef GPUDEBUG
+  G4cout<<"kinE="<< kineticEnergy <<" cut="<< cut <<" emax="<< emax <<".  Calling SetupForMaterial..."<< G4endl;
+#endif
   SetupForMaterial(particle, couple->GetMaterial(), kineticEnergy);
 
   const G4Element* elm = 
@@ -225,16 +231,25 @@ G4SeltzerBergerModel::SampleSecondaries(
   totalEnergy = kineticEnergy + particleMass;
   densityCorr = densityFactor*totalEnergy*totalEnergy;
   G4double totMomentum = sqrt(kineticEnergy*(totalEnergy + electron_mass_c2));
-  /*
+
+#ifdef GPUDEBUG
   G4cout << "G4SeltzerBergerModel::SampleSecondaries E(MeV)= " 
 	 << kineticEnergy/MeV
 	 << " Z= " << Z << " cut(MeV)= " << cut/MeV 
 	 << " emax(MeV)= " << emax/MeV << " corr= " << densityCorr << G4endl;
-  */
+#endif
+
   G4double xmin = log(cut*cut + densityCorr);
   G4double xmax = log(emax*emax  + densityCorr);
   G4double y = log(kineticEnergy/MeV);
 
+#ifdef GPUDEBUG
+  std::cout<<"SB model: kinE="<< kineticEnergy <<" cut="<< cut <<" emax="<< emax <<".  Calling SetupForMaterial..."<< std::endl;
+
+  std::cout<<"SB model: Z="<< Z <<", totE="<< totalEnergy <<", densCorr="<< densityCorr
+	   <<" xmin="<< xmin <<" xmax="<< xmax <<", y="<< y << std::endl;
+#endif
+
   G4double gammaEnergy, v; 
 
   // majoranta
@@ -253,16 +268,23 @@ G4SeltzerBergerModel::SampleSecondaries(
   }
   if(x0 < 0.05) { vmax *= 1.2; }
 
-  //G4cout<<"y= "<<y<<" xmin= "<<xmin<<" xmax= "<<xmax<<" vmax= "<<vmax<<G4endl;
-  //  G4int ncount = 0;
   do {
     //++ncount;
-    G4double x = exp(xmin + G4UniformRand()*(xmax - xmin)) - densityCorr;
+    G4double auxrand = G4UniformRand();
+    G4double x = exp(xmin + auxrand*(xmax - xmin)) - densityCorr;
     if(x < 0.0) { x = 0.0; }
     gammaEnergy = sqrt(x);
     G4double x1 = gammaEnergy/kineticEnergy;
     v = dataSB[Z]->Value(x1, y);
 
+#ifdef GPUDEBUG
+    std::cout<<"SB model: auxrand="<< auxrand
+	     <<", gammaEne="<< gammaEnergy
+	     <<", x1="<< x1 <<", y="<< y
+	     <<", v="<< v
+	     << std::endl;
+#endif
+
     // correction for positrons        
     if(!isElectron) {
       G4double e1 = kineticEnergy - cut;
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/utils/include/G4VEmProcess.hh geant4.9.6.p01-valid/source/processes/electromagnetic/utils/include/G4VEmProcess.hh
--- geant4.9.6.p01-orig/source/processes/electromagnetic/utils/include/G4VEmProcess.hh	2013-02-06 06:50:30.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/utils/include/G4VEmProcess.hh	2013-10-30 12:53:06.728527876 -0500
@@ -425,6 +425,7 @@ inline G4double G4VEmProcess::GetElectro
 inline void G4VEmProcess::DefineMaterial(const G4MaterialCutsCouple* couple)
 {
   if(couple != currentCouple) {
+    G4cout<<"G4VEmProcess.cc: currentCouple reset to "<< couple << G4endl;
     currentCouple   = couple;
     currentMaterial = couple->GetMaterial();
     baseMaterial = currentMaterial->GetBaseMaterial();
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh geant4.9.6.p01-valid/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh
--- geant4.9.6.p01-orig/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh	2013-02-06 06:50:30.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh	2013-12-12 12:23:02.513371240 -0600
@@ -723,6 +723,11 @@ inline G4double G4VEnergyLossProcess::Sc
 
 inline G4double G4VEnergyLossProcess::GetLambdaForScaledEnergy(G4double e)
 {
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.hh: e="<< e <<" fFactor="<< fFactor
+	<<" lambda(e)="<< ((*theLambdaTable)[basedCoupleIndex])->Value(e)
+  	<<" - basedCoupleIndex="<< basedCoupleIndex << G4endl;
+#endif
   return fFactor*((*theLambdaTable)[basedCoupleIndex])->Value(e);
 }
 
@@ -965,6 +970,9 @@ inline void G4VEnergyLossProcess::SetLam
 
 void G4VEnergyLossProcess::SetStepFunction(G4double v1, G4double v2)
 {
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProc.h: SetStepFunction called: currentCouple=0"<< G4endl;
+#endif
   dRoverRange = v1;
   finalRange = v2;
   if (dRoverRange > 0.999) { dRoverRange = 1.0; }
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/utils/src/G4EmCalculator.cc geant4.9.6.p01-valid/source/processes/electromagnetic/utils/src/G4EmCalculator.cc
--- geant4.9.6.p01-orig/source/processes/electromagnetic/utils/src/G4EmCalculator.cc	2013-02-06 06:50:32.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/utils/src/G4EmCalculator.cc	2013-11-12 15:03:35.981761104 -0600
@@ -967,6 +967,9 @@ G4bool G4EmCalculator::UpdateCouple(cons
   currentMaterialName = material->GetName();
   for (G4int i=0; i<nLocalMaterials; ++i) {
     if(material == localMaterials[i] && cut == localCuts[i]) {
+#ifdef GPUDEBUG
+      G4cout<<"G4EmCalculator.cc: Resetting currentCouple to "<< localCouples[i] << G4endl;
+#endif
       currentCouple = localCouples[i];
       currentCoupleIndex = currentCouple->GetIndex();
       currentCut = cut;
diff -rupN geant4.9.6.p01-orig/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc geant4.9.6.p01-valid/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
--- geant4.9.6.p01-orig/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc	2013-02-06 06:50:32.000000000 -0600
+++ geant4.9.6.p01-valid/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc	2013-12-31 10:55:22.306061630 -0600
@@ -151,6 +151,9 @@
 #include "G4EmConfigurator.hh"
 #include "G4VAtomDeexcitation.hh"
 #include "G4EmBiasingManager.hh"
+#ifdef GPUPLOTS
+  #include "G4dataBuffer.hh"
+#endif
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
 
@@ -1016,19 +1019,37 @@ G4double G4VEnergyLossProcess::PostStepG
     currentInteractionLength = 1.0/preStepLambda;
     x = theNumberOfInteractionLengthLeft * currentInteractionLength;
 
-#ifdef G4VERBOSE
-    if (verboseLevel>2){
+#ifdef GPUPLOTS
+    G4dataBuffer& g4buffer = G4dataBuffer::getInstance();
+    if( this->GetProcessName() == "eBrem" ) {
+      g4buffer.getBuffer("hbremPreStepLambda").push_back(preStepLambda);
+      g4buffer.getBuffer("hbremPreStepScaledEnergy").push_back(preStepScaledEnergy);
+      g4buffer.getBuffer("hbremNbOfIntLengthLeft").push_back(theNumberOfInteractionLengthLeft);
+    }
+    else if( this->GetProcessName() == "eIoni" ) {
+      g4buffer.getBuffer("hioniPreStepLambda").push_back(preStepLambda);
+      g4buffer.getBuffer("hioniPreStepScaledEnergy").push_back(preStepScaledEnergy);
+      g4buffer.getBuffer("hioniNbOfIntLengthLeft").push_back(theNumberOfInteractionLengthLeft);
+      g4buffer.getBuffer("hioniMassRatio").push_back(massRatio);
+    }
+    else {
+      G4cout<<" G4VEnergyLossProcess.cc: "<< this->GetProcessName() << G4endl;
+    }
+#endif
+
+    if(verboseLevel>2) {
     //  if(particle->GetPDGMass() > 0.9*GeV){
       G4cout << "G4VEnergyLossProcess::PostStepGetPhysicalInteractionLength ";
       G4cout << "[ " << GetProcessName() << "]" << G4endl; 
       G4cout << " for " << track.GetDefinition()->GetParticleName() 
              << " in Material  " <<  currentMaterial->GetName()
 	     << " Ekin(MeV)= " << preStepKinEnergy/MeV 
-	     <<G4endl;
+	     << G4endl;
       G4cout << "MeanFreePath = " << currentInteractionLength/cm << "[cm]" 
 	     << "InteractionLength= " << x/cm <<"[cm] " <<G4endl;
+      G4cout<<"G4VEnergyLossProc: "<< preStepLambda <<' '<< theNumberOfInteractionLengthLeft
+	    <<' '<< preStepScaledEnergy << G4endl;
     }
-#endif
   }
   return x;
 }
@@ -1091,15 +1112,36 @@ G4VParticleChange* G4VEnergyLossProcess:
 
   // Short step
   eloss = GetDEDXForScaledEnergy(preStepScaledEnergy)*length;
+#ifdef GPUPLOTS
+  G4dataBuffer& g4buffer = G4dataBuffer::getInstance();
+  g4buffer.getBuffer("hioniDedxForScaledEnergyTimesLength").push_back(eloss);
+#endif
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLossProcess.cc::AlongStepDoIt: preStepScaledE="<< preStepScaledEnergy
+	<<" length="<< length << G4endl;
+#endif
 
   // Long step
-  if(eloss > preStepKinEnergy*linLossLimit) {
+#ifdef GPUDEBUG
+  std::cout<<"G4VEnergyLossProcess.cc: Eloss="<< eloss
+	   <<" preStepKinE * linLossLimit="<< preStepKinEnergy*linLossLimit
+	   <<" - Eloss required to be larger for ElossFromKinE-ScaledE calculation!"
+	   << std::endl;
+#endif
+   if(eloss > preStepKinEnergy*linLossLimit) {
 
     //G4double x = GetScaledRangeForScaledEnergy(preStepScaledEnergy) 
     //  - length/reduceFactor;
     G4double x = (fRange - length)/reduceFactor;
     eloss = preStepKinEnergy - ScaledKinEnergyForLoss(x)/massRatio;
-   
+#ifdef GPUDEBUG
+  std::cout<<" fRange="<< fRange <<" length="<< length <<" reduceFactor="<< reduceFactor
+	   <<" x="<< x <<" commentedX="<< (fRange - length/reduceFactor)
+	   <<" Eloss="<< eloss << std::endl;
+#endif
+#ifdef GPUPLOTS
+    g4buffer.getBuffer("hioniElossFromKinEnergyMinusScaledEnergyForLoss").push_back(eloss);
+#endif
     /*
     if(-1 < verboseLevel) 
       G4cout << "Long STEP: rPre(mm)= " 
@@ -1169,6 +1211,12 @@ G4VParticleChange* G4VEnergyLossProcess:
  	eloss -= GetSubDEDXForScaledEnergy(preStepScaledEnergy)*length;
 	esec = SampleSubCutSecondaries(scTracks, step, 
 				       currentModel,currentCoupleIndex);
+#ifdef GPUDEBUG
+  std::cout<<" G4VEneLossProc.cc: subcut sampling (not implemented in GPU): esec="<< esec
+	   <<" cut="<< cut
+	   <<" Eloss="<< eloss << std::endl;
+#endif
+
 	// add bremsstrahlung sampling
 	/*
 	if(nProcesses > 0) {
@@ -1196,6 +1244,13 @@ G4VParticleChange* G4VEnergyLossProcess:
   // Sample fluctuations
   if (lossFluctuationFlag) {
     G4VEmFluctuationModel* fluc = currentModel->GetModelOfFluctuations();
+#ifdef GPUDEBUG
+    std::cout<<"G4VEneLossProc.cc: fluc(T/F)="<< fluc <<" Eloss="<< eloss
+	     <<" esec="<< esec <<" and lowestKinE="<< lowestKinEnergy
+	     <<" --> sum="<< (eloss + esec + lowestKinEnergy)
+	     <<" vs. preStepKinE="<< preStepKinEnergy << std::endl;
+    std::cout<<"G4VEneLossProc.cc: If above sum < preStepKinE - then sample fluctuations will be calculated\n";
+#endif
     if(fluc && 
       (eloss + esec + lowestKinEnergy) < preStepKinEnergy) {
 
@@ -1204,9 +1259,15 @@ G4VParticleChange* G4VEnergyLossProcess:
       G4double emean = eloss;
       eloss = fluc->SampleFluctuations(currentMaterial,dynParticle,
 				       tmax,length,emean);
-      /*                            
-      if(-1 < verboseLevel) 
-      G4cout << "After fluct: eloss(MeV)= " << eloss/MeV
+#ifdef GPUDEBUG
+    std::cout<<"G4VEneLossProc.cc: tmax="<< tmax
+	     <<" emean="<< emean <<" Eloss=" << eloss << std::endl;
+#endif
+#ifdef GPUPLOTS
+      g4buffer.getBuffer("hioniElossFromSampleFluctuations").push_back(eloss);
+#endif
+      /*
+      G4cout << "G4VEnergyLossProcess.cc::AlongStepDoIt: After fluct: eloss(MeV)= " << eloss/MeV
              << " fluc= " << (eloss-eloss0)/MeV
              << " ChargeSqRatio= " << chargeSqRatio
              << " massRatio= " << massRatio
@@ -1240,6 +1301,11 @@ G4VParticleChange* G4VEnergyLossProcess:
       esec += esecfluo;
       eloss = 0.0; 
     } 
+#ifdef GPUDEBUG
+    std::cout<<"G4VEneLossProc.cc: Deexcitation (not implemented in GPU): esecfluo="<< esecfluo
+	     <<" de="<< de <<" esec="<< esec
+	     <<" Eloss=" << eloss << std::endl;
+#endif
     /*    
     if(esecfluo > 0.0) {
       G4cout << "### 2: E(keV)= " << preStepKinEnergy/keV
@@ -1249,11 +1315,11 @@ G4VParticleChange* G4VEnergyLossProcess:
 	     << " Eloss(keV)= " << eloss/keV 
 	     << G4endl; 
     } 
-    */   
+    */
   }
   if(scTracks.size() > 0) { FillSecondariesAlongStep(eloss, weight); }
 
-  // Energy balanse
+  // Energy balance
   G4double finalT = preStepKinEnergy - eloss - esec;
   if (finalT <= lowestKinEnergy) {
     eloss += finalT;
@@ -1268,6 +1334,12 @@ G4VParticleChange* G4VEnergyLossProcess:
   fParticleChange.SetProposedKineticEnergy(finalT);
   fParticleChange.ProposeLocalEnergyDeposit(eloss);
 
+#ifdef GPUDEBUG
+  std::cout<<"G4VEneLossProc.cc: finalT="<< finalT <<" Eloss="<< eloss << std::endl;
+#endif
+#ifdef GPUPLOTS
+  g4buffer.getBuffer("hioniEloss").push_back(eloss);
+#endif
   if(1 < verboseLevel) {
     G4double del = finalT + eloss + esec - preStepKinEnergy;
     G4cout << "Final value eloss(MeV)= " << eloss/MeV
@@ -1278,7 +1350,7 @@ G4VParticleChange* G4VEnergyLossProcess:
            << "  status= " << track.GetTrackStatus()
            << G4endl;
   }
-  
+
   return &fParticleChange;
 }
 
@@ -1327,6 +1399,7 @@ G4VEnergyLossProcess::SampleSubCutSecond
   if(cut <= subcut) { return esec; }
 
   const G4Track* track = step.GetTrack();
+
   const G4DynamicParticle* dp = track->GetDynamicParticle();
   G4double e = dp->GetKineticEnergy()*massRatio;
   G4double cross = (*theDensityFactor)[idx]*chargeSqRatio
@@ -1472,6 +1545,9 @@ G4VParticleChange* G4VEnergyLossProcess:
   // sample secondaries
   secParticles.clear();
   //G4cout << "Energy of primary: " << dynParticle->GetKineticEnergy()/MeV<<G4endl;
+#ifdef GPUDEBUG
+  G4cout<<"G4VEnergyLoss: calling SampleSecondaries with currentCouple="<< currentCouple << G4endl;
+#endif
   currentModel->SampleSecondaries(&secParticles, currentCouple, dynParticle, tcut);
 
   // bremsstrahlung splitting or Russian roulette  
@@ -1737,6 +1813,11 @@ G4double G4VEnergyLossProcess::CrossSect
   if(theLambdaTable) {
     cross = (*theDensityFactor)[currentCoupleIndex]*
       ((*theLambdaTable)[basedCoupleIndex])->Value(kineticEnergy);
+#ifdef GPUDEBUG
+    G4cout<<" G4VEnergyLossProcess.cc::xSecPerVolume: "<< kineticEnergy
+	  <<' '<< (*theDensityFactor)[currentCoupleIndex]
+	  <<' '<< ((*theLambdaTable)[basedCoupleIndex])->Value(kineticEnergy) << G4endl;
+#endif
   } else {
     SelectModel(kineticEnergy);
     cross = currentModel->CrossSectionPerVolume(currentMaterial,
diff -rupN geant4.9.6.p01-orig/source/run/src/G4PhysicsListHelper.cc geant4.9.6.p01-valid/source/run/src/G4PhysicsListHelper.cc
--- geant4.9.6.p01-orig/source/run/src/G4PhysicsListHelper.cc	2013-02-06 06:50:19.000000000 -0600
+++ geant4.9.6.p01-valid/source/run/src/G4PhysicsListHelper.cc	2013-10-31 16:48:26.193698760 -0500
@@ -110,6 +110,7 @@ void G4PhysicsListHelper::CheckParticleL
   while( (*theParticleIterator)() ){
     G4ParticleDefinition* particle = theParticleIterator->value();
     G4String name = particle->GetParticleName();
+    G4cout<<"particle="<<name<<G4endl;
     // check if any EM process exists
     if (!isEmProc) {
       G4ProcessVector* list = particle->GetProcessManager()->GetProcessList();
diff -rupN geant4.9.6.p01-orig/source/track/include/G4Step.hh geant4.9.6.p01-valid/source/track/include/G4Step.hh
--- geant4.9.6.p01-orig/source/track/include/G4Step.hh	2013-02-06 06:50:20.000000000 -0600
+++ geant4.9.6.p01-valid/source/track/include/G4Step.hh	2013-11-01 12:22:31.298007025 -0500
@@ -201,26 +201,26 @@ class G4Step
 // Secondary buckets
 public:
   // secodaries in the current step
-   const std::vector<const G4Track*>* GetSecondaryInCurrentStep() const; 
+   const std::vector<const G4Track*>* GetSecondaryInCurrentStep() const;
 
-   // NOTE: Secondary bucket of the Step contains  
-   //       all secondaries during tracking the current track 
+   // NOTE: Secondary bucket of the Step contains
+   //       all secondaries during tracking the current track
    //       (i.e. NOT secondaries produced in the current step)
    // all following methods give same object (i.e. G4TrackVector  )
-   // but 2nd one will create bucket in addition  
+   // but 2nd one will create bucket in addition
    const G4TrackVector* GetSecondary() const ;
    G4TrackVector* GetfSecondary();
    G4TrackVector* NewSecondaryVector();
 
    // just delete secondary bucket
-   //  NOTE: G4Track objects inside the bucket are not deleted 
+   //  NOTE: G4Track objects inside the bucket are not deleted
    void DeleteSecondaryVector();
 
-   // Add secondary tracks to the bucket 
+   // Add secondary tracks to the bucket
    void SetSecondary( G4TrackVector* value);
 
-private: 
-   // Secondaty bucket implemented by using  std::vector of G4Track*   
+private:
+   // Secondaty bucket implemented by using  std::vector of G4Track*
    G4TrackVector* fSecondary;
 
    // number of secondaries which have been created by the last step
