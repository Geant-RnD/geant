diff --git a/geant4/source/geometry/navigation/src/G4Navigator.cc b/geant4/source/geometry/navigation/src/G4Navigator.cc
index e92c06f..6b204d5 100644
--- a/geant4/source/geometry/navigation/src/G4Navigator.cc
+++ b/geant4/source/geometry/navigation/src/G4Navigator.cc
@@ -1556,7 +1556,13 @@ void G4Navigator::ComputeStepLog(const G4ThreeVector& pGlobalpoint,
     G4double shiftOrigin = std::sqrt(shiftOriginSafSq);
     G4double diffShiftSaf = shiftOrigin - fPreviousSafety;
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
     if( diffShiftSaf > fAccuracyForWarning )
+#else
+    // Currently the initial point of the Track is not realistic and/or the previous
+    // step is not set realistically, so this warning is triggered all the times.
+    if (0)
+#endif
     {
       G4int oldcoutPrec= G4cout.precision(8);
       G4int oldcerrPrec= G4cerr.precision(10);
@@ -1616,6 +1622,8 @@ void G4Navigator::ComputeStepLog(const G4ThreeVector& pGlobalpoint,
     }
 #endif
   }
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+   // See comment above.
   G4double safetyPlus = fPreviousSafety + fAccuracyForException;
   if ( shiftOriginSafSq > sqr(safetyPlus) )
   {
@@ -1628,6 +1636,7 @@ void G4Navigator::ComputeStepLog(const G4ThreeVector& pGlobalpoint,
     G4Exception("G4Navigator::ComputeStep()", "GeomNav1002",
                 JustWarning, message);
   }
+#endif
 }
 
 // ********************************************************************
diff --git a/geant4/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc b/geant4/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc
index 316e2c7..7de153c 100644
--- a/geant4/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc
+++ b/geant4/source/processes/electromagnetic/standard/src/G4MollerBhabhaModel.cc
@@ -362,6 +362,7 @@ void G4MollerBhabhaModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp
     } while(grej * G4UniformRand() > z);
   }
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   G4double deltaKinEnergy = x * kineticEnergy;
 
   G4double deltaMomentum =
@@ -389,6 +390,9 @@ void G4MollerBhabhaModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp
   G4DynamicParticle* delta = new G4DynamicParticle(theElectron,
 						   deltaDirection,deltaKinEnergy);
   vdp->push_back(delta);
+#else
+   // dwjang : wait until deciding how to handle secondaries
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
diff --git a/geant4/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc b/geant4/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc
index 9df96b5..d2ddeed 100644
--- a/geant4/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc
+++ b/geant4/source/processes/electromagnetic/standard/src/G4SeltzerBergerModel.cc
@@ -201,6 +201,10 @@ G4SeltzerBergerModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp,
 					G4double cutEnergy,
 					G4double maxEnergy)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+#else
+   return;
+#endif
   G4double kineticEnergy = dp->GetKineticEnergy();
   G4double cut  = std::min(cutEnergy, kineticEnergy);
   G4double emax = std::min(maxEnergy, kineticEnergy);
diff --git a/geant4/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc b/geant4/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc
index 48e0898..b0df3d7 100644
--- a/geant4/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc
+++ b/geant4/source/processes/electromagnetic/standard/src/G4UrbanMscModel95.cc
@@ -425,7 +425,7 @@ G4double G4UrbanMscModel95::ComputeTruePathLengthLimit(
 
   const G4DynamicParticle* dp = track.GetDynamicParticle();
 
-  if(stepStatus == fUndefined) {
+   if(stepStatus == fUndefined) {
     inside = false;
     insideskin = false;
     tlimit = geombig;
@@ -434,11 +434,26 @@ G4double G4UrbanMscModel95::ComputeTruePathLengthLimit(
 
   theLambdaTable = theTable;
   couple = track.GetMaterialCutsCouple();
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   currentMaterialIndex = couple->GetIndex();
   currentKinEnergy = dp->GetKineticEnergy();
   currentRange = GetRange(particle,currentKinEnergy,couple);
-  lambda0 = GetLambda(currentKinEnergy);
-
+#else
+   // The cuda version does not set up the materials couple
+   // in the track, so it fakes it.
+  currentMaterialIndex = 1;
+  currentKinEnergy = 100.0;
+  // currentRange = GetRange(currentKinEnergy);
+   {
+      double kinEnergy = currentKinEnergy;
+      G4double dedx = 2.0*MeV*cm2/g;
+      G4double density = 5.16797e+19; // for electron
+      G4double localrange = kinEnergy/(dedx*density);
+      currentRange = localrange;
+   }
+#endif
+   lambda0 = GetLambda(currentKinEnergy);
+   
   // stop here if small range particle
   if(inside) { return tPathLength; }            
   
@@ -462,7 +477,7 @@ G4double G4UrbanMscModel95::ComputeTruePathLengthLimit(
   //
   if (steppingAlgorithm == fUseDistanceToBoundary)
     {
-      //compute geomlimit and presafety 
+      //compute geomlimit and presafety
       G4double geomlimit = ComputeGeomLimit(track, presafety, currentRange);
 
       // is it far from boundary ?
@@ -577,8 +592,12 @@ G4double G4UrbanMscModel95::ComputeTruePathLengthLimit(
     {
       // compute presafety again if presafety <= 0 and no boundary
       // i.e. when it is needed for optimization purposes
-      if((stepStatus != fGeomBoundary) && (presafety < tlimitminfix)) 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
+      if((stepStatus != fGeomBoundary) && (presafety < tlimitminfix))
 	presafety = ComputeSafety(sp->GetPosition(),tPathLength); 
+#else
+       // @@ dwjang : will implement this part later
+#endif
 
       // is far from boundary
       if(currentRange < presafety)
diff --git a/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc b/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc
index 9b6cdf9..277b61d 100644
--- a/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc
+++ b/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlung.cc
@@ -120,9 +120,14 @@ G4eBremsstrahlung::InitialiseEnergyLossProcess(const G4ParticleDefinition*,
     SetIonisation(false);
 
     //    if (!EmModel(1)) { SetEmModel(new G4eBremsstrahlungModel(), 1); }
+#ifdef NO_BACKPORT_CUDA_REMOVALS
     if (!EmModel(1)) { SetEmModel(new G4SeltzerBergerModel(), 1); }
     if (!EmModel(2)) { SetEmModel(new G4eBremsstrahlungRelModel(), 2); }
-
+#else
+    if (!EmModel(1)) { SetEmModel(new G4eBremsstrahlungModel(), 1); }
+    if (!EmModel(2)) { SetEmModel(new G4eBremsstrahlungModel(), 2); }
+#endif
+     
     G4double energyLimit = 1*GeV;
 
     EmModel(1)->SetLowEnergyLimit(MinKinEnergy());
diff --git a/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc b/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc
index d02d90f..b3fec66 100644
--- a/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc
+++ b/geant4/source/processes/electromagnetic/standard/src/G4eBremsstrahlungModel.cc
@@ -637,6 +637,223 @@ G4DataVector* G4eBremsstrahlungModel::ComputePartialSumSigma(
   return dv;
 }
 
+#if 0
+
+static G4double ComputeCrossSectionPerAtom(double kineticEnergy, double Z,
+                                            G4double cut) {
+	G4double cross = 0.0;
+   
+	if (kineticEnergy < keV || kineticEnergy < cut) {
+		return cross;
+	}
+   
+	const G4double ksi = 2.0;
+	//  const G4double alfa=1.00;
+	const G4double csigh = 0.127, csiglow = 0.25, asiglow = 0.020 * MeV;
+	const G4double Tlim = 10. * MeV;
+   
+	const G4double xlim = 1.2;
+   
+	const int NZ = 8;
+	const int Nsig = 11;
+	const float ZZ[NZ] = { 2., 4., 6., 14., 26., 50., 82., 92. };
+	const float coefsig[NZ][Nsig] = { { 0.4638, 0.37748, 0.32249, -0.060362,
+      -0.065004, -0.033457, -0.004583, 0.011954, 0.0030404, -0.0010077,
+      -0.00028131 },
+      
+      { 0.50008, 0.33483, 0.34364, -0.086262, -0.055361, -0.028168, -0.0056172,
+			0.011129, 0.0027528, -0.00092265, -0.00024348 },
+      
+      { 0.51587, 0.31095, 0.34996, -0.11623, -0.056167, -0.0087154, 0.00053943,
+			0.0054092, 0.00077685, -0.00039635, -6.7818e-05 },
+      
+      { 0.55058, 0.25629, 0.35854, -0.080656, -0.054308, -0.049933, -0.00064246,
+			0.016597, 0.0021789, -0.001327, -0.00025983 },
+      
+      { 0.5791, 0.26152, 0.38953, -0.17104, -0.099172, 0.024596, 0.023718,
+			-0.0039205, -0.0036658, 0.00041749, 0.00023408 },
+      
+      { 0.62085, 0.27045, 0.39073, -0.37916, -0.18878, 0.23905, 0.095028,
+			-0.068744, -0.023809, 0.0062408, 0.0020407 },
+      
+      { 0.66053, 0.24513, 0.35404, -0.47275, -0.22837, 0.35647, 0.13203, -0.1049,
+			-0.034851, 0.0095046, 0.0030535 },
+      
+      { 0.67143, 0.23079, 0.32256, -0.46248, -0.20013, 0.3506, 0.11779, -0.1024,
+			-0.032013, 0.0092279, 0.0028592 } };
+   
+	int iz = 0;
+	G4double delz = 1.0e6;
+	for (int ii = 0; ii < NZ; ii++) {
+		G4double absdelz = fabs(Z - ZZ[ii]);
+		if (absdelz < delz) {
+			iz = ii;
+			delz = absdelz;
+		}
+	}
+   
+	G4double xx = log10(kineticEnergy / MeV);
+	G4double fs = 1.0;
+   
+	if (xx <= xlim) {
+		fs = coefsig[iz][Nsig - 1];
+		for (int j = Nsig - 2; j >= 0; j--) {
+			fs = fs * xx + coefsig[iz][j];
+		}
+		if (fs < 0.0) {
+			fs = 0.0;
+		}
+	}
+   
+	//  cross = Z*(Z+ksi)*(1.-csigh*exp(log(Z)/4.))*pow(log(kineticEnergy/cut),alfa);
+	cross = Z * (Z + ksi) * (1. - csigh * exp(log(Z) / 4.))
+   * log(kineticEnergy / cut);
+   
+	if (kineticEnergy <= Tlim) {
+		cross *= exp(csiglow * log(Tlim / kineticEnergy))
+      * (1. + asiglow / (sqrt(Z) * kineticEnergy));
+	}
+   
+	if (!isElectron)
+		cross *= PositronCorrFactorSigma(Z, kineticEnergy, cut);
+   
+	cross *= fs / Avogadro;
+   
+	if (cross < 0.0) {
+		cross = 0.0;
+	}
+   
+	return cross;
+}
+
+static G4double CrossSectionPerVolume(double kineticEnergy,
+                               G4double cutEnergy, double maxEnergy) {
+   
+	G4double cross = 0.0;
+	G4double tmax = (maxEnergy < kineticEnergy) ? maxEnergy : kineticEnergy;
+	G4double cut = (cutEnergy < kineticEnergy) ? cutEnergy : kineticEnergy;
+	if (cut >= tmax) {
+		return cross;
+	}
+   
+	// material : PbWO4
+	// density : 5.16797e+19
+	// electron density : 2.06011e+21
+	// radlen : 8.92421
+	// effZ, effA : 68.3599, 170.87
+	// name: Lead, symbol:Pb, Z: 82, density: 1.0958e+19
+	// name: Tungstenm, symbol:W, Z: 74, density: 1.0958e+19
+	// name: Oxygen, symbol:O2, Z: 8, density: 4.3832e+19
+   
+	const int nElements = 3;
+	const G4double theAtomNumDensity[nElements] = { 1.0958e+19, 1.0958e+19,
+      4.3832e+19 };
+	const G4double Z[nElements] = { 82, 74, 8 };
+   
+	for (int i = 0; i < nElements; i++) {
+		cross += theAtomNumDensity[i]
+      * ComputeCrossSectionPerAtom(kineticEnergy, Z[i], cut);
+		if (tmax < kineticEnergy) {
+			cross -= theAtomNumDensity[i]
+         * ComputeCrossSectionPerAtom(kineticEnergy, Z[i], tmax);
+		}
+	}
+   
+	// now compute the correction due to the supression(s)
+   
+	G4double kmax = tmax;
+	G4double kmin = cut;
+   
+	G4double totalEnergy = kineticEnergy + electron_mass_c2;
+	//  G4double kp2 = MigdalConstant*totalEnergy*totalEnergy
+	//                                             *(material->GetElectronDensity());
+	G4double MigdalConstant = classic_electr_radius * electron_Compton_length
+   * electron_Compton_length * 4.0 * pi;
+	// PbW04 electorn density : 2.06011e+21
+	G4double kp2 = MigdalConstant * totalEnergy * totalEnergy * 2.06011e+21;
+   
+	G4double fsig = 0.;
+	int nmax = 100;
+	G4double vmin = log(kmin);
+	G4double vmax = log(kmax);
+	G4double highKinEnergy = 100.0 * TeV;
+	int nn = (int) (nmax * (vmax - vmin) / (log(highKinEnergy) - vmin));
+	G4double u, fac, c, v, dv, y;
+	if (nn > 0) {
+      
+		dv = (vmax - vmin) / nn;
+		v = vmin - dv;
+		for (int n = 0; n <= nn; n++) {
+         
+			v += dv;
+			u = exp(v);
+			fac = SupressionFunction(kineticEnergy, u, LPMFlag);
+			y = u / kmax;
+			fac *= (4. - 4. * y + 3. * y * y) / 3.;
+			//        fac *= probsup*(u*u/(u*u+kp2))+1.-probsup;
+			fac *= (u * u / (u * u + kp2));
+         
+			if ((n == 0) || (n == nn))
+				c = 0.5;
+			else
+				c = 1.;
+         
+			fac *= c;
+			fsig += fac;
+		}
+		y = kmin / kmax;
+		fsig *= dv
+      / (-4. * log(y) / 3. - 4. * (1. - y) / 3. + 0.5 * (1. - y * y));
+      
+	} else {
+      
+		fsig = 1.;
+	}
+	if (fsig > 1.)
+		fsig = 1.;
+   
+	// correct the cross section
+	cross *= fsig;
+   
+	return cross;
+   
+}
+
+static G4double GXBrem_GPVEmModel_CrossSectionPerVolume(double ekin, double emin,
+                                                  G4double emax) {
+	G4double cross = 0.0;
+	const G4double theAtomNumDensity[nElements] = { 1.0958e+19, 1.0958e+19,
+      4.3832e+19 };
+   
+	for (int i = 0; i < nElements; i++) {
+		cross += theAtomNumDensity[i]
+      * ComputeCrossSectionPerAtom(ekin, emin, emax);
+		xsec[i] = cross;
+	}
+	return cross;
+}
+
+//int GPVEmModel_SelectRandomAtom(G4double kinEnergy, double tcut, double tmax) {
+static int GXBrem__SelectRandomAtom(G4double kinEnergy, double tcut, double tmax) {
+   // Note that in Geant4, the function actually called is G4VEmModel::SelectRandomAtom
+   // (which requires quite a bit more setup that is currently done/ported here)
+   
+   const nElements = 3;
+	int n = nElements - 1;
+	if (n > 0) {
+		G4double x = rand_wrapper(localState)
+      * GXBrem_GPVEmModel_CrossSectionPerVolume(kinEnergy, tcut, tmax);
+		for (int i = 0; i < n; ++i) {
+			if (x <= xsec[i]) {
+				return i;
+			}
+		}
+	}
+	return n;
+}
+
+#endif
+
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
 
 void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>* vdp, 
@@ -689,15 +906,51 @@ void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>*
 
   G4double gammaEnergy;
   G4bool LPMOK = false;
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   const G4Material* material = couple->GetMaterial();
-
+#endif
+   
   // select randomly one element constituing the material
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   const G4Element* anElement = SelectRandomAtom(couple);
-
-  // Extract Z factors for this Element
-  G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
-  G4double FZ = lnZ* (4.- 0.55*lnZ);
-  G4double ZZ = anElement->GetIonisation()->GetZZ3();
+   
+   // Extract Z factors for this Element
+   G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
+   G4double FZ = lnZ* (4.- 0.55*lnZ);
+   G4double ZZ = anElement->GetIonisation()->GetZZ3();
+#else
+	// moved to GPConstants.h
+	// const int nElements = 3;
+	// const G4double theAtomNumDensity[nElements] = {1.0958e+19, 1.0958e+19, 4.3832e+19};
+	// const G4double Z[nElements] = {82, 74, 8};
+   
+	// tcut = 0.00099 MeV used above in GXBrem::GetCurrentLambda, taken from eBremsstralung
+   G4Material *material = G4Material::GetMaterial("PbWO4");
+   const G4Element* anElement = G4VEmModel::SelectRandomAtom(material,dp->GetParticleDefinition(),kineticEnergy,tmax);
+
+   G4double lnZ = 3.*(anElement->GetIonisation()->GetlogZ3());
+   G4double FZ = lnZ* (4.- 0.55*lnZ);
+   G4double ZZ = anElement->GetIonisation()->GetZZ3();
+
+//   int iElement = SelectRandomAtom(kineticEnergy, 0.00099, tmax);
+//   
+//	//  const G4double theAtomNumDensity[nElements] = {1.0958e+19, 1.0958e+19, 4.3832e+19};
+//
+//	const int nElements = 3;
+//	const G4double Z[nElements] = { 82, 74, 8 };
+//   
+//	// from G4IonisParamElm.hh
+//	//G4double fZ;                 // effective Z
+//	//G4double fZ3;                // std::pow (Z,1/3)
+//	//G4double fZZ3;               // std::pow (Z(Z+1),1/3)
+//	//G4double flogZ3;             // std::log(Z)/3
+//   
+//	// Extract Z factors for this Element
+//	G4double lnZ = 3. * pow(Z[iElement], 1 / 3.);
+//	G4double FZ = log(Z[iElement]) * (4. - 0.55 * log(Z[iElement]));
+//	G4double ZZ = pow(Z[iElement] * (Z[iElement] + 1), 1 / 3.);
+   
+#endif
 
   // limits of the energy sampling
   G4double totalEnergy = kineticEnergy + electron_mass_c2;
@@ -820,6 +1073,7 @@ void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>*
 
   } while (!LPMOK);
 
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   //
   // angles of the emitted gamma. ( Z - axis along the parent particle)
   // use general interface
@@ -861,6 +1115,7 @@ void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>*
     fParticleChange->SetProposedMomentumDirection(direction);
     fParticleChange->SetProposedKineticEnergy(finalE);
   }
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
@@ -868,31 +1123,31 @@ void G4eBremsstrahlungModel::SampleSecondaries(std::vector<G4DynamicParticle*>*
 const G4Element* G4eBremsstrahlungModel::SelectRandomAtom(
            const G4MaterialCutsCouple* couple) 
 {
-  // select randomly 1 element within the material
+   // select randomly 1 element within the material
 
-  const G4Material* material = couple->GetMaterial();
-  G4int nElements = material->GetNumberOfElements();
-  const G4ElementVector* theElementVector = material->GetElementVector();
+   const G4Material* material = couple->GetMaterial();
+   G4int nElements = material->GetNumberOfElements();
+   const G4ElementVector* theElementVector = material->GetElementVector();
 
-  const G4Element* elm = 0;
+   const G4Element* elm = 0;
 
-  if(1 < nElements) {
+   if(1 < nElements) {
 
-    --nElements; 
-    G4DataVector* dv = partialSumSigma[couple->GetIndex()];
-    G4double rval = G4UniformRand()*((*dv)[nElements]);
+      --nElements;
+      G4DataVector* dv = partialSumSigma[couple->GetIndex()];
+      G4double rval = G4UniformRand()*((*dv)[nElements]);
 
-    elm = (*theElementVector)[nElements];
-    for (G4int i=0; i<nElements; ++i) {
-      if (rval <= (*dv)[i]) {
-	elm = (*theElementVector)[i];
-	break;
+      elm = (*theElementVector)[nElements];
+      for (G4int i=0; i<nElements; ++i) {
+         if (rval <= (*dv)[i]) {
+            elm = (*theElementVector)[i];
+            break;
+         }
       }
-    }
-  } else { elm = (*theElementVector)[0]; }
+   } else { elm = (*theElementVector)[0]; }
  
-  SetCurrentElement(elm);
-  return elm;
+   SetCurrentElement(elm);
+   return elm;
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
diff --git a/geant4/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh b/geant4/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh
index b274828..517f0eb 100644
--- a/geant4/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh
+++ b/geant4/source/processes/electromagnetic/utils/include/G4VEnergyLossProcess.hh
@@ -714,7 +714,11 @@ inline G4double G4VEnergyLossProcess::ScaledKinEnergyForLoss(G4double r)
 
 inline G4double G4VEnergyLossProcess::GetLambdaForScaledEnergy(G4double e)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   return fFactor*((*theLambdaTable)[basedCoupleIndex])->Value(e);
+#else
+  return fFactor*((*theLambdaTable)[1])->Value(e);
+#endif
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
@@ -814,6 +818,7 @@ G4VEnergyLossProcess::GetLambda(G4double& kineticEnergy,
 
 inline void G4VEnergyLossProcess::ComputeLambdaForScaledEnergy(G4double e)
 {
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   mfpKinEnergy  = theEnergyOfCrossSectionMax[currentCoupleIndex];
   if (e <= mfpKinEnergy) {
     preStepLambda = GetLambdaForScaledEnergy(e);
@@ -831,6 +836,26 @@ inline void G4VEnergyLossProcess::ComputeLambdaForScaledEnergy(G4double e)
       preStepLambda = fFactor*theCrossSectionMax[currentCoupleIndex];
     }
   }
+#else
+   // We dont really have couple information ...
+   mfpKinEnergy = 0.00713103;
+	if (e <= mfpKinEnergy) {
+		preStepLambda = GetLambdaForScaledEnergy(e);
+	} else {
+		G4double e1 = e * lambdaFactor;
+		if (e1 > mfpKinEnergy) {
+			preStepLambda = GetLambdaForScaledEnergy(e);
+			G4double preStepLambda1 = GetLambdaForScaledEnergy(e1);
+			if (preStepLambda1 > preStepLambda) {
+				mfpKinEnergy = e1;
+				preStepLambda = preStepLambda1;
+			}
+		} else {
+			//      preStepLambda = fFactor*theCrossSectionMax[currentCoupleIndex];
+			preStepLambda = 3.4635;
+		}
+	}
+#endif
 }
 
 // ======== Get/Set inline methods used at initialisation ================
diff --git a/geant4/source/processes/electromagnetic/utils/src/G4VEmModel.cc b/geant4/source/processes/electromagnetic/utils/src/G4VEmModel.cc
index 403d6b2..236848a 100644
--- a/geant4/source/processes/electromagnetic/utils/src/G4VEmModel.cc
+++ b/geant4/source/processes/electromagnetic/utils/src/G4VEmModel.cc
@@ -210,20 +210,20 @@ const G4Element* G4VEmModel::SelectRandomAtom(const G4Material* material,
 					      G4double tcut,
 					      G4double tmax)
 {
-  const G4ElementVector* theElementVector = material->GetElementVector();
-  G4int n = material->GetNumberOfElements() - 1;
-  fCurrentElement = (*theElementVector)[n];
-  if (n > 0) {
-    G4double x = G4UniformRand()*
-                 G4VEmModel::CrossSectionPerVolume(material,pd,kinEnergy,tcut,tmax);
-    for(G4int i=0; i<n; ++i) {
-      if (x <= xsec[i]) {
-	fCurrentElement = (*theElementVector)[i];
-	break;
+   const G4ElementVector* theElementVector = material->GetElementVector();
+   G4int n = material->GetNumberOfElements() - 1;
+   fCurrentElement = (*theElementVector)[n];
+   if (n > 0) {
+      G4double x = G4UniformRand()*
+      G4VEmModel::CrossSectionPerVolume(material,pd,kinEnergy,tcut,tmax);
+      for(G4int i=0; i<n; ++i) {
+         if (x <= xsec[i]) {
+            fCurrentElement = (*theElementVector)[i];
+            break;
+         }
       }
-    }
-  }
-  return fCurrentElement;
+   }
+   return fCurrentElement;
 }
 
 //....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
diff --git a/geant4/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc b/geant4/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
index 25ca037..53b5f75 100644
--- a/geant4/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
+++ b/geant4/source/processes/electromagnetic/utils/src/G4VEnergyLossProcess.cc
@@ -917,6 +917,8 @@ G4double G4VEnergyLossProcess::PostStepGetPhysicalInteractionLength(
   SelectModel(preStepScaledEnergy);
   if(!currentModel->IsActive(preStepScaledEnergy)) { return x; }
 
+   // dwjang : model selection checks whether this model is applicable in the given energy range.
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // change effective charge of an ion on fly
   if(isIon) {
     G4double q2 = currentModel->ChargeSquareRatio(track);
@@ -926,11 +928,14 @@ G4double G4VEnergyLossProcess::PostStepGetPhysicalInteractionLength(
       reduceFactor = 1.0/(fFactor*massRatio);
     }
   }
-  //G4cout << "q2= " << chargeSqRatio << " massRatio= " << massRatio << G4endl; 
+#endif
+  //G4cout << "q2= " << chargeSqRatio << " massRatio= " << massRatio << G4endl;
   // initialisation for sampling of the interaction length 
   if(previousStepSize <= 0.0) { theNumberOfInteractionLengthLeft = -1.0; }
   if(theNumberOfInteractionLengthLeft < 0.0) { mfpKinEnergy = DBL_MAX; }
 
+   // dwjang : not considering bias at this moment
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // forced biasing only for primary particles
   if(biasManager) {
     if(0 == track.GetParentID()) {
@@ -943,6 +948,7 @@ G4double G4VEnergyLossProcess::PostStepGetPhysicalInteractionLength(
       }
     }
   }
+#endif
 
   // compute mean free path
   if(preStepScaledEnergy < mfpKinEnergy) {
@@ -1397,8 +1403,14 @@ G4VParticleChange* G4VEnergyLossProcess::PostStepDoIt(const G4Track& track,
   }
 
   const G4DynamicParticle* dynParticle = track.GetDynamicParticle();
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   G4double tcut = (*theCuts)[currentCoupleIndex];
-
+#else
+   // dwjang : weight = 1, tcut = 0.00099 MeV
+   G4double tcut = 0.00099;  
+#endif
+   
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   // sample secondaries
   secParticles.clear();
   currentModel->SampleSecondaries(&secParticles, currentCouple, dynParticle, tcut);
@@ -1409,7 +1421,7 @@ G4VParticleChange* G4VEnergyLossProcess::PostStepDoIt(const G4Track& track,
       weight *= biasManager->ApplySecondaryBiasing(secParticles,currentCoupleIndex);
     }
   }
-
+   
   // save secondaries
   G4int num = secParticles.size();
   if(num > 0) {
@@ -1425,6 +1437,10 @@ G4VParticleChange* G4VEnergyLossProcess::PostStepDoIt(const G4Track& track,
       }
     }
   }
+#else
+   secParticles.clear();
+   currentModel->SampleSecondaries(&secParticles, currentCouple, dynParticle, tcut);
+#endif
 
   if(0.0 == fParticleChange.GetProposedKineticEnergy() &&
      fAlive == fParticleChange.GetTrackStatus()) {
diff --git a/geant4/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc b/geant4/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc
index b1e3bcb..151cf36 100644
--- a/geant4/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc
+++ b/geant4/source/processes/electromagnetic/utils/src/G4VMultipleScattering.cc
@@ -355,9 +355,13 @@ G4double G4VMultipleScattering::AlongStepGetPhysicalInteractionLength(
   // get Step limit proposed by the process
   *selection = NotCandidateForSelection;
   G4double x = currentMinimalStep;
+#ifdef NO_BACKPORT_CUDA_REMOVALS
   DefineMaterial(track.GetMaterialCutsCouple());
   G4double ekin = track.GetKineticEnergy();
   if(isIon) { ekin *= proton_mass_c2/track.GetParticleDefinition()->GetPDGMass(); }
+#else
+   G4double ekin = 100.;
+#endif
   currentModel = static_cast<G4VMscModel*>(SelectModel(ekin));
 
   // define ionisation process
