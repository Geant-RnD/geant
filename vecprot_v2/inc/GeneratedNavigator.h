// The following code is an autogenerated and specialized Navigator 
// obtained from the NavigationSpecializerService ( which is part of VecGeom )
// ADD INFORMATION ABOUT INPUT FILES, DATE, MD5 HASH OF INPUTFILES
// ADD INFORMATION ABOUT WHICH PARTS HAVE BEEN SPECIALIZED 
// DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING 

#include "navigation/VNavigator.h"
#include "navigation/NavigationState.h"
#include "base/Transformation3D.h"
#include "management/GeoManager.h"
#include <Vc/Vc>
#include "backend/Backend.h"
// more relevant includes to be figures out ... 
#include "volumes/Box.h"
#include "volumes/Trapezoid.h"
#include "volumes/Tube.h"
#include "volumes/Polycone.h"
#include "volumes/Polyhedron.h"
#include "volumes/Trd.h"
#include "volumes/Cone.h"
#include "volumes/BooleanVolume.h"


namespace vecgeom {
inline namespace VECGEOM_IMPL_NAMESPACE {
class GeneratedNavigator : public VNavigatorHelper<GeneratedNavigator,1> {
private:

// automatically generated function to transform a path for liquidArgon into an array index
static size_t PathToIndex( NavigationState const *path ){
size_t finalindex=0;
{
// it might be better to init to -1 ( to detect possible inconsitencies )
size_t levelindex(0);
switch (path->ValueAt( 2 )){
 case 2 : { levelindex = 0; break; }
 case 5 : { levelindex = 1; break; }
 case 6 : { levelindex = 2; break; }
 case 7 : { levelindex = 3; break; }
 case 8 : { levelindex = 4; break; }
 case 9 : { levelindex = 5; break; }
 case 10 : { levelindex = 6; break; }
 case 11 : { levelindex = 7; break; }
 case 12 : { levelindex = 8; break; }
 case 13 : { levelindex = 9; break; }
}
finalindex += levelindex * 1;
}
return finalindex;
}


static constexpr double gTrans0[10] = {-6.25, -4.75, -3.25, -1.75, -0.25, 1.25, 2.75, 4.25, 5.75, 7.25};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot0[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot4[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot8[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// ------- generated tables ------
static constexpr double globalTranstrans0[10] = {-6.25, -4.75, -3.25, -1.75, -0.25, 1.25, 2.75, 4.25, 5.75, 7.25};
static constexpr double globalTransrot0= 1;
static constexpr double globalTransrot4= 1;
static constexpr double globalTransrot8= 1;
static constexpr short deltamatrixmapping[10][4] = {{0,-1,1,7},{-1,0,1,8},{-1,0,1,10},{-1,0,1,11},{-1,0,1,4},{-1,0,1,5},{-1,0,1,2},{-1,0,1,9},{-1,0,1,6},{-1,-1,1,3}};
static constexpr double gDeltaTrans0[12] = {0.75, -0.75, -2.75, -7.25, 0.25, -1.25, -5.75, 6.25, 4.75, -4.25, 3.25, 1.75};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot0[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot4[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot8[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

public:
static constexpr const char *gClassNameString="GeneratedNavigator";
typedef SimpleSafetyEstimator SafetyEstimator_t;

static VNavigator *Instance(){
static GeneratedNavigator instance;
return &instance;}

template <typename T>
 VECGEOM_INLINE
 static void DoGlobalToLocalTransformation(NavigationState const &in_state,Vector3D<T> const &globalpoint, Vector3D<T> const &globaldir,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState * internal)  {
auto index = PathToIndex( &in_state );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal->SetCacheValue(index);
Vector3D<Precision> tmp( globalpoint[0]- globalTranstrans0[index]
, globalpoint[1], globalpoint[2]);
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
localdir[0]=globaldir[0];
localdir[1]=globaldir[1];
localdir[2]=globaldir[2];
}
template <typename T, unsigned int ChunkSize>
VECGEOM_INLINE
 static void DoGlobalToLocalTransformations(NavigationState const ** in_states,SOA3D<Precision> const &globalpoints,SOA3D<Precision> const &globaldirs, unsigned int from_index,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState ** internal) {
T globalTranstrans0_v;
T globalTransrot0_v;
T globalTransrot4_v;
T globalTransrot8_v;
// filling the vectors from the tabulated data 
// TODO: index independent data should come first (outside the loop)
for(size_t i=0;i<ChunkSize;++i){
auto trackindex = from_index + i;
auto index = PathToIndex( in_states[trackindex] );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal[trackindex]->SetCacheValue(index);
globalTranstrans0_v[i] = globalTranstrans0[index];
}
Vector3D<T> gpoint_v(T(globalpoints.x()+from_index),T(globalpoints.y()+from_index),T(globalpoints.z()+from_index));
Vector3D<T> gdir_v(T(globaldirs.x()+from_index),T(globaldirs.y()+from_index),T(globaldirs.z()+from_index));
Vector3D<T> tmp_v( gpoint_v.x()- globalTranstrans0_v
, gpoint_v.y(), gpoint_v.z());
localpoint[0]=tmp_v[0];
localpoint[1]=tmp_v[1];
localpoint[2]=tmp_v[2];
localdir[0]=gdir_v[0];
localdir[1]=gdir_v[1];
localdir[2]=gdir_v[2];
}
template <typename T> VECGEOM_INLINE static T TreatDistanceToMother(VPlacedVolume const *pvol, Vector3D<T> const &localpoint, Vector3D<T> const &localdir, T step_limit) {
T step;
assert(pvol != nullptr && "currentvolume is null in navigation");
step = ((SpecializedBox<-1,-1>*)pvol)->SpecializedBox<-1,-1>::DistanceToOut(localpoint, localdir, step_limit);
MaskedAssign(step < T(0.), kInfinity, &step);
return step;
}
VECGEOM_INLINE static Precision PrepareOutState(NavigationState const &in_state, NavigationState &out_state, Precision geom_step, Precision step_limit, VPlacedVolume const *hitcandidate, bool &done){
// this is the special part ( fast navigation state copying since we know the depth at compile time )
in_state.CopyToFixedSize<NavigationState::SizeOf(3)>(&out_state);
// this is just the first try -- we should factor out the following part which is probably not 
// special code
done = false;
if (geom_step == kInfinity && step_limit > 0.) {geom_step = vecgeom::kTolerance;out_state.SetBoundaryState(true);out_state.Pop();done=true;return geom_step;}
// is geometry further away than physics step?
// this is a physics step
if (geom_step > step_limit) {// don't need to do anything
geom_step = step_limit;out_state.SetBoundaryState(false);return geom_step;}
out_state.SetBoundaryState(true);
if (geom_step < 0.) {// InspectEnvironmentForPointAndDirection( globalpoint, globaldir, currentstate );
geom_step = 0.;}return geom_step;}
virtual Precision ComputeStepAndHittingBoundaryForLocalPoint(Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir, Precision pstep, NavigationState const & in_state, NavigationState & out_state) const override {
 assert(false && "reached unimplemented point");
 return -1;
}
virtual bool CheckDaughterIntersections(LogicalVolume const *lvol, Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir,                                           NavigationState const & in_state, NavigationState & out_state, Precision &step, VPlacedVolume const *& hitcandidate) const override {
return false;
}
VECGEOM_INLINE
virtual void Relocate(Vector3D<Precision> const &pointafterboundary, NavigationState const &__restrict__ in_state,NavigationState &__restrict__ out_state) const override {
// this means that we are leaving the mother
// alternatively we could use nextvolumeindex like before
// this was probably calculated before 
auto pathindex = out_state.GetCacheValue();
if(pathindex < 0){ pathindex = PathToIndex(&in_state);
 }{
// considering transition /horiz/-1
short index = deltamatrixmapping[pathindex][2];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[3];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + -1 );
return;}
}
}
{
// considering transition /up/horiz/1/down/3
short index = deltamatrixmapping[pathindex][1];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[3];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + 1 );
out_state.PushIndexType(3);
return;}
}
}
{
// considering transition /up/horiz/3/down/3
short index = deltamatrixmapping[pathindex][0];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[3];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + 3 );
out_state.PushIndexType(3);
return;}
}
}
{
// considering transition /up/up/up
short index = deltamatrixmapping[pathindex][3];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[0];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
out_state.Pop();
out_state.Pop();
return;}
}
}
}
}; // end class

constexpr double GeneratedNavigator::globalTranstrans0[];
constexpr double GeneratedNavigator::globalTransrot0;
constexpr double GeneratedNavigator::globalTransrot4;
constexpr double GeneratedNavigator::globalTransrot8;
constexpr short GeneratedNavigator::deltamatrixmapping[10][4];
constexpr double GeneratedNavigator::gDeltaTrans0[12];
constexpr double GeneratedNavigator::gDeltaRot0[12];
constexpr double GeneratedNavigator::gDeltaRot4[12];
constexpr double GeneratedNavigator::gDeltaRot8[12];

}} // end namespace
