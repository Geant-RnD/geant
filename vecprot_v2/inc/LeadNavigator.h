// The following code is an autogenerated and specialized Navigator 
// obtained from the NavigationSpecializerService ( which is part of VecGeom )
// ADD INFORMATION ABOUT INPUT FILES, DATE, MD5 HASH OF INPUTFILES
// ADD INFORMATION ABOUT WHICH PARTS HAVE BEEN SPECIALIZED 
// DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING 

#include "navigation/VNavigator.h"
#include "navigation/NavigationState.h"
#include "base/Transformation3D.h"
#include "management/GeoManager.h"
#include <Vc/Vc>
#include "backend/Backend.h"
// more relevant includes to be figures out ... 
#include "volumes/Box.h"
#include "volumes/Trapezoid.h"
#include "volumes/Tube.h"
#include "volumes/Polycone.h"
#include "volumes/Polyhedron.h"
#include "volumes/Trd.h"
#include "volumes/Cone.h"
#include "volumes/BooleanVolume.h"
#include "navigation/SimpleSafetyEstimator.h"


namespace vecgeom {
inline namespace VECGEOM_IMPL_NAMESPACE {
class LeadNavigator : public VNavigatorHelper<LeadNavigator,1> {
private:

// automatically generated function to transform a path for Lead into an array index
static size_t PathToIndex( NavigationState const *path ){
size_t finalindex=0;
{
// it might be better to init to -1 ( to detect possible inconsitencies )
size_t levelindex(0);
switch (path->ValueAt( 2 )){
 case 2 : { levelindex = 0; break; }
 case 5 : { levelindex = 1; break; }
 case 6 : { levelindex = 2; break; }
 case 7 : { levelindex = 3; break; }
 case 8 : { levelindex = 4; break; }
 case 9 : { levelindex = 5; break; }
 case 10 : { levelindex = 6; break; }
 case 11 : { levelindex = 7; break; }
 case 12 : { levelindex = 8; break; }
 case 13 : { levelindex = 9; break; }
}
finalindex += levelindex * 1;
}
return finalindex;
}


static constexpr double gTrans0[10] = {-7, -5.5, -4, -2.5, -1, 0.5, 2, 3.5, 5, 6.5};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot0[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot4[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot8[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// ------- generated tables ------
static constexpr double globalTranstrans0[10] = {-7, -5.5, -4, -2.5, -1, 0.5, 2, 3.5, 5, 6.5};
static constexpr double globalTransrot0= 1;
static constexpr double globalTransrot4= 1;
static constexpr double globalTransrot8= 1;
static constexpr short deltamatrixmapping[10][4] = {{0,4,-1,-1},{0,1,-1,2},{0,10,2,-1},{0,11,2,-1},{0,5,2,-1},{0,6,2,-1},{0,3,2,-1},{0,8,2,-1},{0,7,2,-1},{0,9,2,-1}};
static constexpr double gDeltaTrans0[12] = {0.75, 5.5, -0.75, -2, 7, 1, -0.5, -5, -3.5, -6.5, 4, 2.5};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot0[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot4[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot8[12] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

public:
static constexpr const char *gClassNameString="LeadNavigator";
typedef SimpleSafetyEstimator SafetyEstimator_t;

static VNavigator *Instance(){
static LeadNavigator instance;
return &instance;}

template <typename T>
 VECGEOM_INLINE
 static void DoGlobalToLocalTransformation(NavigationState const &in_state,Vector3D<T> const &globalpoint, Vector3D<T> const &globaldir,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState * internal)  {
auto index = PathToIndex( &in_state );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal->SetCacheValue(index);
Vector3D<Precision> tmp( globalpoint[0]- globalTranstrans0[index]
, globalpoint[1], globalpoint[2]);
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
localdir[0]=globaldir[0];
localdir[1]=globaldir[1];
localdir[2]=globaldir[2];
}
template <typename T, unsigned int ChunkSize>
VECGEOM_INLINE
 static void DoGlobalToLocalTransformations(NavigationState const ** in_states,SOA3D<Precision> const &globalpoints,SOA3D<Precision> const &globaldirs, unsigned int from_index,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState ** internal) {
T globalTranstrans0_v;
T globalTransrot0_v;
T globalTransrot4_v;
T globalTransrot8_v;
// filling the vectors from the tabulated data 
// TODO: index independent data should come first (outside the loop)
for(size_t i=0;i<ChunkSize;++i){
auto trackindex = from_index + i;
auto index = PathToIndex( in_states[trackindex] );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal[trackindex]->SetCacheValue(index);
globalTranstrans0_v[i] = globalTranstrans0[index];
}
Vector3D<T> gpoint_v(T(globalpoints.x()+from_index),T(globalpoints.y()+from_index),T(globalpoints.z()+from_index));
Vector3D<T> gdir_v(T(globaldirs.x()+from_index),T(globaldirs.y()+from_index),T(globaldirs.z()+from_index));
Vector3D<T> tmp_v( gpoint_v.x()- globalTranstrans0_v
, gpoint_v.y(), gpoint_v.z());
localpoint[0]=tmp_v[0];
localpoint[1]=tmp_v[1];
localpoint[2]=tmp_v[2];
localdir[0]=gdir_v[0];
localdir[1]=gdir_v[1];
localdir[2]=gdir_v[2];
}
template <typename T> VECGEOM_INLINE static T TreatDistanceToMother(VPlacedVolume const *pvol, Vector3D<T> const &localpoint, Vector3D<T> const &localdir, T step_limit) {
T step;
assert(pvol != nullptr && "currentvolume is null in navigation");
step = ((SpecializedBox<-1,-1>*)pvol)->SpecializedBox<-1,-1>::DistanceToOut(localpoint, localdir, step_limit);
MaskedAssign(step < T(0.), kInfinity, &step);
return step;
}
VECGEOM_INLINE static Precision PrepareOutState(NavigationState const &in_state, NavigationState &out_state, Precision geom_step, Precision step_limit, VPlacedVolume const *hitcandidate, bool &done){
// this is the special part ( fast navigation state copying since we know the depth at compile time )
in_state.CopyToFixedSize<NavigationState::SizeOf(3)>(&out_state);
// this is just the first try -- we should factor out the following part which is probably not 
// special code
done = false;
if (geom_step == kInfinity && step_limit > 0.) {geom_step = vecgeom::kTolerance;out_state.SetBoundaryState(true);out_state.Pop();done=true;return geom_step;}
// is geometry further away than physics step?
// this is a physics step
if (geom_step > step_limit) {// don't need to do anything
geom_step = step_limit;out_state.SetBoundaryState(false);return geom_step;}
out_state.SetBoundaryState(true);
if (geom_step < 0.) {// InspectEnvironmentForPointAndDirection( globalpoint, globaldir, currentstate );
geom_step = 0.;}return geom_step;}
virtual Precision ComputeStepAndHittingBoundaryForLocalPoint(Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir, Precision pstep, NavigationState const & in_state, NavigationState & out_state) const override {
 assert(false && "reached unimplemented point");
 return -1;
}
virtual bool CheckDaughterIntersections(LogicalVolume const *lvol, Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir,                                           NavigationState const & in_state, NavigationState & out_state, Precision &step, VPlacedVolume const *& hitcandidate) const override {
return false;
}
VECGEOM_INLINE
virtual void Relocate(Vector3D<Precision> const &pointafterboundary, NavigationState const &__restrict__ in_state,NavigationState &__restrict__ out_state) const override {
// this means that we are leaving the mother
// alternatively we could use nextvolumeindex like before
// this was probably calculated before 
auto pathindex = out_state.GetCacheValue();
if(pathindex < 0){ pathindex = PathToIndex(&in_state);
 }{
// considering transition /horiz/1
short index = deltamatrixmapping[pathindex][0];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[4];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + 1 );
return;}
}
}
{
// considering transition /up/horiz/-1/down/4
short index = deltamatrixmapping[pathindex][2];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[4];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + -1 );
out_state.PushIndexType(4);
return;}
}
}
{
// considering transition /up/horiz/-3/down/4
short index = deltamatrixmapping[pathindex][3];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[4];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + -3 );
out_state.PushIndexType(4);
return;}
}
}
{
// considering transition /up/up/up
short index = deltamatrixmapping[pathindex][1];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0]- gDeltaTrans0[index], pointafterboundary[1], pointafterboundary[2]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[0];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
out_state.Pop();
out_state.Pop();
return;}
}
}
}
}; // end class

constexpr double LeadNavigator::globalTranstrans0[];
constexpr double LeadNavigator::globalTransrot0;
constexpr double LeadNavigator::globalTransrot4;
constexpr double LeadNavigator::globalTransrot8;
constexpr short LeadNavigator::deltamatrixmapping[10][4];
constexpr double LeadNavigator::gDeltaTrans0[12];
constexpr double LeadNavigator::gDeltaRot0[12];
constexpr double LeadNavigator::gDeltaRot4[12];
constexpr double LeadNavigator::gDeltaRot8[12];

}} // end namespace
