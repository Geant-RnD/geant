// The following code is an autogenerated and specialized Navigator 
// obtained from the NavigationSpecializerService ( which is part of VecGeom )
// ADD INFORMATION ABOUT INPUT FILES, DATE, MD5 HASH OF INPUTFILES
// ADD INFORMATION ABOUT WHICH PARTS HAVE BEEN SPECIALIZED 
// DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING 

#include "navigation/VNavigator.h"
#include "navigation/NavigationState.h"
#include "base/Transformation3D.h"
#include "management/GeoManager.h"
#include <Vc/Vc>
#include "backend/Backend.h"
// more relevant includes to be figures out ... 
#include "volumes/Box.h"
#include "volumes/Trapezoid.h"
#include "volumes/Tube.h"
#include "volumes/Polycone.h"
#include "volumes/Polyhedron.h"
#include "volumes/Trd.h"
#include "volumes/Cone.h"
#include "volumes/BooleanVolume.h"
#include "navigation/SimpleSafetyEstimator.h"


namespace vecgeom {
inline namespace VECGEOM_IMPL_NAMESPACE {
class FixedShield10Navigator : public VNavigatorHelper<FixedShield10Navigator,0> {
private:

// automatically generated function to transform a path for FixedShield10 into an array index
static size_t PathToIndex( NavigationState const *path ){
size_t finalindex=0;
{
// it might be better to init to -1 ( to detect possible inconsitencies )
size_t levelindex(0);
switch (path->ValueAt( 2 )){
 case 19860 : { levelindex = 0; break; }
 case 20382 : { levelindex = 1; break; }
}
finalindex += levelindex * 1;
}
return finalindex;
}


static constexpr double gTrans2[2] = {1995, -1995};
static constexpr double gRot0[2] = {1, -1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot4[2] = {1, 1};
static constexpr double gRot8[2] = {1, -1};
// ------- generated tables ------
static constexpr double globalTranstrans2[2] = {1995, -1995};
static constexpr double globalTransrot0[2] = {1, -1};
static constexpr double globalTransrot4= 1;
static constexpr double globalTransrot8[2] = {1, -1};
static constexpr short deltamatrixmapping[2][1] = {{0},{0}};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaTrans2[1] = {-1995};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot0[1] = {1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot4[1] = {1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot8[1] = {1};

public:
static constexpr const char *gClassNameString="FixedShield10Navigator";
typedef SimpleSafetyEstimator SafetyEstimator_t;

static VNavigator *Instance(){
static FixedShield10Navigator instance;
return &instance;}

template <typename T>
 VECGEOM_INLINE
 static void DoGlobalToLocalTransformation(NavigationState const &in_state,Vector3D<T> const &globalpoint, Vector3D<T> const &globaldir,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState * internal)  {
auto index = PathToIndex( &in_state );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal->SetCacheValue(index);
Vector3D<Precision> tmp( globalpoint[0], globalpoint[1], globalpoint[2]- globalTranstrans2[index]
);
localpoint[0]=tmp[0] * globalTransrot0[index];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2] * globalTransrot8[index];
localdir[0]=globaldir[0] * globalTransrot0[index];
localdir[1]=globaldir[1];
localdir[2]=globaldir[2] * globalTransrot8[index];
}
template <typename T, unsigned int ChunkSize>
VECGEOM_INLINE
 static void DoGlobalToLocalTransformations(NavigationState const ** in_states,SOA3D<Precision> const &globalpoints,SOA3D<Precision> const &globaldirs, unsigned int from_index,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState ** internal) {
T globalTranstrans2_v;
T globalTransrot0_v;
T globalTransrot4_v;
T globalTransrot8_v;
// filling the vectors from the tabulated data 
// TODO: index independent data should come first (outside the loop)
for(size_t i=0;i<ChunkSize;++i){
auto trackindex = from_index + i;
auto index = PathToIndex( in_states[trackindex] );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal[trackindex]->SetCacheValue(index);
globalTranstrans2_v[i] = globalTranstrans2[index];
globalTransrot0_v[i] = globalTransrot0[index];
globalTransrot8_v[i] = globalTransrot8[index];
}
Vector3D<T> gpoint_v(T(globalpoints.x()+from_index),T(globalpoints.y()+from_index),T(globalpoints.z()+from_index));
Vector3D<T> gdir_v(T(globaldirs.x()+from_index),T(globaldirs.y()+from_index),T(globaldirs.z()+from_index));
Vector3D<T> tmp_v( gpoint_v.x(), gpoint_v.y(), gpoint_v.z()- globalTranstrans2_v
);
localpoint[0]=tmp_v[0] * globalTransrot0_v;
localpoint[1]=tmp_v[1];
localpoint[2]=tmp_v[2] * globalTransrot8_v;
localdir[0]=gdir_v[0] * globalTransrot0_v;
localdir[1]=gdir_v[1];
localdir[2]=gdir_v[2] * globalTransrot8_v;
}
template <typename T> VECGEOM_INLINE static T TreatDistanceToMother(VPlacedVolume const *pvol, Vector3D<T> const &localpoint, Vector3D<T> const &localdir, T step_limit) {
T step;
assert(pvol != nullptr && "currentvolume is null in navigation");
step = ((SpecializedTube<-1,-1,TubeTypes::UniversalTube>*)pvol)->SpecializedTube<-1,-1,TubeTypes::UniversalTube>::DistanceToOut(localpoint, localdir, step_limit);
MaskedAssign(step < T(0.), kInfinity, &step);
return step;
}
VECGEOM_INLINE static Precision PrepareOutState(NavigationState const &in_state, NavigationState &out_state, Precision geom_step, Precision step_limit, VPlacedVolume const *hitcandidate, bool &done){
// this is the special part ( fast navigation state copying since we know the depth at compile time )
in_state.CopyToFixedSize<NavigationState::SizeOf(3)>(&out_state);
// this is just the first try -- we should factor out the following part which is probably not 
// special code
done = false;
if (geom_step == kInfinity && step_limit > 0.) {geom_step = vecgeom::kTolerance;out_state.SetBoundaryState(true);out_state.Pop();done=true;return geom_step;}
// is geometry further away than physics step?
// this is a physics step
if (geom_step > step_limit) {// don't need to do anything
geom_step = step_limit;out_state.SetBoundaryState(false);return geom_step;}
out_state.SetBoundaryState(true);
if (geom_step < 0.) {// InspectEnvironmentForPointAndDirection( globalpoint, globaldir, currentstate );
geom_step = 0.;}return geom_step;}
virtual Precision ComputeStepAndHittingBoundaryForLocalPoint(Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir, Precision pstep, NavigationState const & in_state, NavigationState & out_state) const override {
 assert(false && "reached unimplemented point");
 return -1;
}
virtual bool CheckDaughterIntersections(LogicalVolume const *lvol, Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir,                                           NavigationState const & in_state, NavigationState & out_state, Precision &step, VPlacedVolume const *& hitcandidate) const override {
return false;
}
VECGEOM_INLINE
virtual void Relocate(Vector3D<Precision> const &pointafterboundary, NavigationState const &__restrict__ in_state,NavigationState &__restrict__ out_state) const override {
// this means that we are leaving the mother
// alternatively we could use nextvolumeindex like before
// this was probably calculated before 
auto pathindex = out_state.GetCacheValue();
if(pathindex < 0){ pathindex = PathToIndex(&in_state);
 }{
// considering transition /up
short index = deltamatrixmapping[pathindex][0];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0], pointafterboundary[1], pointafterboundary[2]- gDeltaTrans2[index]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[19860];
bool intarget = ((SpecializedPolycone<-1,-1>const *) pvol)->SpecializedPolycone<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
return;}
}
}
}
}; // end class

constexpr double FixedShield10Navigator::globalTranstrans2[];
constexpr double FixedShield10Navigator::globalTransrot0[];
constexpr double FixedShield10Navigator::globalTransrot4;
constexpr double FixedShield10Navigator::globalTransrot8[];
constexpr short FixedShield10Navigator::deltamatrixmapping[2][1];
constexpr double FixedShield10Navigator::gDeltaTrans2[1];
constexpr double FixedShield10Navigator::gDeltaRot0[1];
constexpr double FixedShield10Navigator::gDeltaRot4[1];
constexpr double FixedShield10Navigator::gDeltaRot8[1];

}} // end namespace
