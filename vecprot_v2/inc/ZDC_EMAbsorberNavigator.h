// The following code is an autogenerated and specialized Navigator 
// obtained from the NavigationSpecializerService ( which is part of VecGeom )
// ADD INFORMATION ABOUT INPUT FILES, DATE, MD5 HASH OF INPUTFILES
// ADD INFORMATION ABOUT WHICH PARTS HAVE BEEN SPECIALIZED 
// DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING 

#include "navigation/VNavigator.h"
#include "navigation/NavigationState.h"
#include "base/Transformation3D.h"
#include "management/GeoManager.h"
#include <Vc/Vc>
#include "backend/Backend.h"
// more relevant includes to be figures out ... 
#include "volumes/Box.h"
#include "volumes/Trapezoid.h"
#include "volumes/Tube.h"
#include "volumes/Polycone.h"
#include "volumes/Polyhedron.h"
#include "volumes/Trd.h"
#include "volumes/Cone.h"
#include "volumes/BooleanVolume.h"
#include "navigation/SimpleSafetyEstimator.h"


namespace vecgeom {
inline namespace VECGEOM_IMPL_NAMESPACE {
class ZDC_EMAbsorberNavigator : public VNavigatorHelper<ZDC_EMAbsorberNavigator,1> {
private:

// automatically generated function to transform a path for ZDC_EMAbsorber into an array index
static size_t PathToIndex( NavigationState const *path ){
size_t finalindex=0;
{
// it might be better to init to -1 ( to detect possible inconsitencies )
size_t levelindex(0);
switch (path->ValueAt( 2 )){
 case 20396 : { levelindex = 0; break; }
 case 20735 : { levelindex = 1; break; }
}
finalindex += levelindex * 1;
}
{
// it might be better to init to -1 ( to detect possible inconsitencies )
size_t levelindex(0);
switch (path->ValueAt( 3 )){
 case 20535 : { levelindex = 0; break; }
 case 20647 : { levelindex = 1; break; }
 case 20648 : { levelindex = 2; break; }
 case 20649 : { levelindex = 3; break; }
 case 20650 : { levelindex = 4; break; }
 case 20651 : { levelindex = 5; break; }
 case 20652 : { levelindex = 6; break; }
 case 20653 : { levelindex = 7; break; }
 case 20654 : { levelindex = 8; break; }
 case 20655 : { levelindex = 9; break; }
 case 20656 : { levelindex = 10; break; }
 case 20657 : { levelindex = 11; break; }
 case 20658 : { levelindex = 12; break; }
 case 20659 : { levelindex = 13; break; }
 case 20660 : { levelindex = 14; break; }
 case 20661 : { levelindex = 15; break; }
 case 20662 : { levelindex = 16; break; }
 case 20663 : { levelindex = 17; break; }
 case 20664 : { levelindex = 18; break; }
 case 20665 : { levelindex = 19; break; }
 case 20666 : { levelindex = 20; break; }
 case 20667 : { levelindex = 21; break; }
 case 20668 : { levelindex = 22; break; }
 case 20669 : { levelindex = 23; break; }
 case 20670 : { levelindex = 24; break; }
 case 20671 : { levelindex = 25; break; }
 case 20672 : { levelindex = 26; break; }
 case 20673 : { levelindex = 27; break; }
 case 20674 : { levelindex = 28; break; }
 case 20675 : { levelindex = 29; break; }
 case 20676 : { levelindex = 30; break; }
 case 20677 : { levelindex = 31; break; }
 case 20678 : { levelindex = 32; break; }
}
finalindex += levelindex * 2;
}
return finalindex;
}


static constexpr double gTrans2[66] = {13950.100000000000363797880709171295, -13950.100000000000363797880709171295, 13950.400000000001455191522836685181, -13950.400000000001455191522836685181, 13950.70000000000072759576141834259, -13950.70000000000072759576141834259, 13951, -13951, 13951.300000000001091393642127513885, -13951.300000000001091393642127513885, 13951.600000000000363797880709171295, -13951.600000000000363797880709171295, 13951.900000000001455191522836685181, -13951.900000000001455191522836685181, 13952.20000000000072759576141834259, -13952.20000000000072759576141834259, 13952.5, -13952.5, 13952.800000000001091393642127513885, -13952.800000000001091393642127513885, 13953.100000000000363797880709171295, -13953.100000000000363797880709171295, 13953.400000000001455191522836685181, -13953.400000000001455191522836685181, 13953.70000000000072759576141834259, -13953.70000000000072759576141834259, 13954, -13954, 13954.300000000001091393642127513885, -13954.300000000001091393642127513885, 13954.600000000000363797880709171295, -13954.600000000000363797880709171295, 13954.900000000001455191522836685181, -13954.900000000001455191522836685181, 13955.20000000000072759576141834259, -13955.20000000000072759576141834259, 13955.5, -13955.5, 13955.800000000001091393642127513885, -13955.800000000001091393642127513885, 13956.100000000000363797880709171295, -13956.100000000000363797880709171295, 13956.400000000001455191522836685181, -13956.400000000001455191522836685181, 13956.70000000000072759576141834259, -13956.70000000000072759576141834259, 13957, -13957, 13957.300000000001091393642127513885, -13957.300000000001091393642127513885, 13957.600000000000363797880709171295, -13957.600000000000363797880709171295, 13957.900000000001455191522836685181, -13957.900000000001455191522836685181, 13958.20000000000072759576141834259, -13958.20000000000072759576141834259, 13958.5, -13958.5, 13958.800000000001091393642127513885, -13958.800000000001091393642127513885, 13959.100000000000363797880709171295, -13959.100000000000363797880709171295, 13959.400000000001455191522836685181, -13959.400000000001455191522836685181, 13959.70000000000072759576141834259, -13959.70000000000072759576141834259};
static constexpr double gRot0[66] = {1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gRot4[66] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
static constexpr double gRot8[66] = {1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1};
// ------- generated tables ------
static constexpr double globalTranstrans2[66] = {13950.100000000000363797880709171295, -13950.100000000000363797880709171295, 13950.400000000001455191522836685181, -13950.400000000001455191522836685181, 13950.70000000000072759576141834259, -13950.70000000000072759576141834259, 13951, -13951, 13951.300000000001091393642127513885, -13951.300000000001091393642127513885, 13951.600000000000363797880709171295, -13951.600000000000363797880709171295, 13951.900000000001455191522836685181, -13951.900000000001455191522836685181, 13952.20000000000072759576141834259, -13952.20000000000072759576141834259, 13952.5, -13952.5, 13952.800000000001091393642127513885, -13952.800000000001091393642127513885, 13953.100000000000363797880709171295, -13953.100000000000363797880709171295, 13953.400000000001455191522836685181, -13953.400000000001455191522836685181, 13953.70000000000072759576141834259, -13953.70000000000072759576141834259, 13954, -13954, 13954.300000000001091393642127513885, -13954.300000000001091393642127513885, 13954.600000000000363797880709171295, -13954.600000000000363797880709171295, 13954.900000000001455191522836685181, -13954.900000000001455191522836685181, 13955.20000000000072759576141834259, -13955.20000000000072759576141834259, 13955.5, -13955.5, 13955.800000000001091393642127513885, -13955.800000000001091393642127513885, 13956.100000000000363797880709171295, -13956.100000000000363797880709171295, 13956.400000000001455191522836685181, -13956.400000000001455191522836685181, 13956.70000000000072759576141834259, -13956.70000000000072759576141834259, 13957, -13957, 13957.300000000001091393642127513885, -13957.300000000001091393642127513885, 13957.600000000000363797880709171295, -13957.600000000000363797880709171295, 13957.900000000001455191522836685181, -13957.900000000001455191522836685181, 13958.20000000000072759576141834259, -13958.20000000000072759576141834259, 13958.5, -13958.5, 13958.800000000001091393642127513885, -13958.800000000001091393642127513885, 13959.100000000000363797880709171295, -13959.100000000000363797880709171295, 13959.400000000001455191522836685181, -13959.400000000001455191522836685181, 13959.70000000000072759576141834259, -13959.70000000000072759576141834259};
static constexpr double globalTransrot0[66] = {1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1};
static constexpr double globalTransrot4= 1;
static constexpr double globalTransrot8[66] = {1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1};
static constexpr short deltamatrixmapping[66][4] = {{0,1,-1,-1},{0,1,-1,-1},{8,1,-1,2},{8,1,-1,2},{28,1,2,-1},{28,1,2,-1},{23,1,2,-1},{23,1,2,-1},{26,1,2,-1},{26,1,2,-1},{29,1,2,-1},{29,1,2,-1},{5,1,2,-1},{5,1,2,-1},{9,1,2,-1},{9,1,2,-1},{33,1,2,-1},{33,1,2,-1},{20,1,2,-1},{20,1,2,-1},{19,1,2,-1},{19,1,2,-1},{12,1,2,-1},{12,1,2,-1},{3,1,2,-1},{3,1,2,-1},{32,1,2,-1},{32,1,2,-1},{22,1,2,-1},{22,1,2,-1},{21,1,2,-1},{21,1,2,-1},{13,1,2,-1},{13,1,2,-1},{6,1,2,-1},{6,1,2,-1},{16,1,2,-1},{16,1,2,-1},{14,1,2,-1},{14,1,2,-1},{7,1,2,-1},{7,1,2,-1},{24,1,2,-1},{24,1,2,-1},{15,1,2,-1},{15,1,2,-1},{4,1,2,-1},{4,1,2,-1},{34,1,2,-1},{34,1,2,-1},{17,1,2,-1},{17,1,2,-1},{27,1,2,-1},{27,1,2,-1},{30,1,2,-1},{30,1,2,-1},{31,1,2,-1},{31,1,2,-1},{11,1,2,-1},{11,1,2,-1},{10,1,2,-1},{10,1,2,-1},{18,1,2,-1},{18,1,2,-1},{25,1,2,-1},{25,1,2,-1}};
static constexpr double gDeltaTrans2[35] = {49.899999999999636202119290828704834, 0.049999999999272404238581657409667969, -0.25, 46.299999999999272404238581657409668, 43, 48.099999999998544808477163314819336, 44.799999999999272404238581657409668, 43.899999999999636202119290828704834, 49.599999999998544808477163314819336, 47.799999999999272404238581657409668, 40.899999999999636202119290828704834, 41.199999999998908606357872486114502, 46.599999999998544808477163314819336, 45.099999999998544808477163314819336, 44.199999999998908606357872486114502, 43.299999999999272404238581657409668, 44.5, 42.399999999999636202119290828704834, 40.599999999998544808477163314819336, 46.899999999999636202119290828704834, 47.199999999998908606357872486114502, 45.399999999999636202119290828704834, 45.699999999998908606357872486114502, 49, 43.599999999998544808477163314819336, 40.299999999999272404238581657409668, 48.699999999998908606357872486114502, 42.099999999998544808477163314819336, 49.299999999999272404238581657409668, 48.399999999999636202119290828704834, 41.799999999999272404238581657409668, 41.5, 46, 47.5, 42.699999999998908606357872486114502};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot0[35] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot4[35] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
// **** HEY: THESE VALUES ARE ALL THE SAME ---> can safe memory
static constexpr double gDeltaRot8[35] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

public:
static constexpr const char *gClassNameString="ZDC_EMAbsorberNavigator";
typedef SimpleSafetyEstimator SafetyEstimator_t;

static VNavigator *Instance(){
static ZDC_EMAbsorberNavigator instance;
return &instance;}

template <typename T>
 VECGEOM_INLINE
 static void DoGlobalToLocalTransformation(NavigationState const &in_state,Vector3D<T> const &globalpoint, Vector3D<T> const &globaldir,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState * internal)  {
auto index = PathToIndex( &in_state );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal->SetCacheValue(index);
Vector3D<Precision> tmp( globalpoint[0], globalpoint[1], globalpoint[2]- globalTranstrans2[index]
);
localpoint[0]=tmp[0] * globalTransrot0[index];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2] * globalTransrot8[index];
localdir[0]=globaldir[0] * globalTransrot0[index];
localdir[1]=globaldir[1];
localdir[2]=globaldir[2] * globalTransrot8[index];
}
template <typename T, unsigned int ChunkSize>
VECGEOM_INLINE
 static void DoGlobalToLocalTransformations(NavigationState const ** in_states,SOA3D<Precision> const &globalpoints,SOA3D<Precision> const &globaldirs, unsigned int from_index,Vector3D<T> &localpoint, Vector3D<T> &localdir, NavigationState ** internal) {
T globalTranstrans2_v;
T globalTransrot0_v;
T globalTransrot4_v;
T globalTransrot8_v;
// filling the vectors from the tabulated data 
// TODO: index independent data should come first (outside the loop)
for(size_t i=0;i<ChunkSize;++i){
auto trackindex = from_index + i;
auto index = PathToIndex( in_states[trackindex] );
// caching this index in internal navigationstate for later reuse
// we know that is safe to do this because of static analysis (never do this in user code)
internal[trackindex]->SetCacheValue(index);
globalTranstrans2_v[i] = globalTranstrans2[index];
globalTransrot0_v[i] = globalTransrot0[index];
globalTransrot8_v[i] = globalTransrot8[index];
}
Vector3D<T> gpoint_v(T(globalpoints.x()+from_index),T(globalpoints.y()+from_index),T(globalpoints.z()+from_index));
Vector3D<T> gdir_v(T(globaldirs.x()+from_index),T(globaldirs.y()+from_index),T(globaldirs.z()+from_index));
Vector3D<T> tmp_v( gpoint_v.x(), gpoint_v.y(), gpoint_v.z()- globalTranstrans2_v
);
localpoint[0]=tmp_v[0] * globalTransrot0_v;
localpoint[1]=tmp_v[1];
localpoint[2]=tmp_v[2] * globalTransrot8_v;
localdir[0]=gdir_v[0] * globalTransrot0_v;
localdir[1]=gdir_v[1];
localdir[2]=gdir_v[2] * globalTransrot8_v;
}
template <typename T> VECGEOM_INLINE static T TreatDistanceToMother(VPlacedVolume const *pvol, Vector3D<T> const &localpoint, Vector3D<T> const &localdir, T step_limit) {
T step;
assert(pvol != nullptr && "currentvolume is null in navigation");
step = ((SpecializedBox<-1,-1>*)pvol)->SpecializedBox<-1,-1>::DistanceToOut(localpoint, localdir, step_limit);
MaskedAssign(step < T(0.), kInfinity, &step);
return step;
}
VECGEOM_INLINE static Precision PrepareOutState(NavigationState const &in_state, NavigationState &out_state, Precision geom_step, Precision step_limit, VPlacedVolume const *hitcandidate, bool &done){
// this is the special part ( fast navigation state copying since we know the depth at compile time )
in_state.CopyToFixedSize<NavigationState::SizeOf(4)>(&out_state);
// this is just the first try -- we should factor out the following part which is probably not 
// special code
done = false;
if (geom_step == kInfinity && step_limit > 0.) {geom_step = vecgeom::kTolerance;out_state.SetBoundaryState(true);out_state.Pop();done=true;return geom_step;}
// is geometry further away than physics step?
// this is a physics step
if (geom_step > step_limit) {// don't need to do anything
geom_step = step_limit;out_state.SetBoundaryState(false);return geom_step;}
out_state.SetBoundaryState(true);
if (geom_step < 0.) {// InspectEnvironmentForPointAndDirection( globalpoint, globaldir, currentstate );
geom_step = 0.;}return geom_step;}
virtual Precision ComputeStepAndHittingBoundaryForLocalPoint(Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir, Precision pstep, NavigationState const & in_state, NavigationState & out_state) const override {
 assert(false && "reached unimplemented point");
 return -1;
}
virtual bool CheckDaughterIntersections(LogicalVolume const *lvol, Vector3D<Precision> const & localpoint, Vector3D<Precision> const & localdir,                                           NavigationState const & in_state, NavigationState & out_state, Precision &step, VPlacedVolume const *& hitcandidate) const override {
return false;
}
VECGEOM_INLINE
virtual void Relocate(Vector3D<Precision> const &pointafterboundary, NavigationState const &__restrict__ in_state,NavigationState &__restrict__ out_state) const override {
// this means that we are leaving the mother
// alternatively we could use nextvolumeindex like before
// this was probably calculated before 
auto pathindex = out_state.GetCacheValue();
if(pathindex < 0){ pathindex = PathToIndex(&in_state);
 }{
// considering transition /up
short index = deltamatrixmapping[pathindex][1];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0], pointafterboundary[1], pointafterboundary[2]- gDeltaTrans2[index]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[20647];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
return;}
}
}
{
// considering transition /up/horiz/-1
short index = deltamatrixmapping[pathindex][2];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0], pointafterboundary[1], pointafterboundary[2]- gDeltaTrans2[index]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[20648];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + -1 );
return;}
}
}
{
// considering transition /up/horiz/-112
short index = deltamatrixmapping[pathindex][3];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0], pointafterboundary[1], pointafterboundary[2]- gDeltaTrans2[index]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[20535];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
auto oldvalue = out_state.ValueAt( out_state.GetCurrentLevel()-1 );
out_state.Pop();
out_state.PushIndexType( oldvalue  + -112 );
return;}
}
}
{
// considering transition /up/up
short index = deltamatrixmapping[pathindex][0];
if(index!=-1){
Vector3D<Precision> tmp( pointafterboundary[0], pointafterboundary[1], pointafterboundary[2]- gDeltaTrans2[index]);
Vector3D<Precision> localpoint;
localpoint[0]=tmp[0];
localpoint[1]=tmp[1];
localpoint[2]=tmp[2];
VPlacedVolume const * pvol = &GeoManager::gCompactPlacedVolBuffer[20396];
bool intarget = ((SpecializedBox<-1,-1>const *) pvol)->SpecializedBox<-1,-1>::UnplacedContains(localpoint);
if(intarget){
out_state.Pop();
out_state.Pop();
return;}
}
}
}
}; // end class

constexpr double ZDC_EMAbsorberNavigator::globalTranstrans2[];
constexpr double ZDC_EMAbsorberNavigator::globalTransrot0[];
constexpr double ZDC_EMAbsorberNavigator::globalTransrot4;
constexpr double ZDC_EMAbsorberNavigator::globalTransrot8[];
constexpr short ZDC_EMAbsorberNavigator::deltamatrixmapping[66][4];
constexpr double ZDC_EMAbsorberNavigator::gDeltaTrans2[35];
constexpr double ZDC_EMAbsorberNavigator::gDeltaRot0[35];
constexpr double ZDC_EMAbsorberNavigator::gDeltaRot4[35];
constexpr double ZDC_EMAbsorberNavigator::gDeltaRot8[35];

}} // end namespace
