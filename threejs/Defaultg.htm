<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Cogevito: Dynamic particles</title>
    <script type="text/javascript" src="lib/three.js"></script>
    <script type="text/javascript" src="lib/THREEx.KeyboardState.js"></script>
    <script type="text/javascript" src="lib/ThreeCSG.js"></script>
    <script type="text/javascript" src="lib/dat.gui.min.js"></script>
    <script type="text/javascript" src="lib/OrbitControls.js"></script>
    <script type="text/javascript" src="lib/cogevitolibg.js"></script>
    <script type="text/javascript" src="tree.js"></script>
    <script type="text/javascript" src="menu.js"></script>
    <style>
    body {
        /* set margin to 0 and overflow to hidden, to go fullscreen */
        margin: 0;
        overflow: hidden;
        background-color: #849378;
    }
    </style>
</head>

<body>
    <div id="WebGL-output">
    
    </div>
    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
    //-----------Javascript

    //
    //  Start definition of particles and their properties
    //

    //Create a canvas to contain the label of the object (mouse over display name)  
    var canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');
    var texture, ObjectLabel;
    VolumeName = "";

    function changeCanvas(label = "") {
        ctx.font = '14pt Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillText(label, canvas.width / 2, canvas.height / 2);
    }

    function init() {


        initParticleSprites()

        fileInput.addEventListener('change', function(event) {

            console.log("Loading data from : ", fileInput.files[0]);
            loadJSON(fileInput.files[0].name, function(response) {
                var JsonGeom = JSON.parse(response);
                if (JsonGeom.Colors) loadColors(JsonGeom);;
                if (JsonGeom.Geometry) {
                    if (!GeometryNotLoaded) disposeGeoTree();
                    loadGeometry(JsonGeom, 0)
                };
                if (JsonGeom.Event) loadEvent(JsonGeom);
            });
        });

        function loadJSON(file, callback) {

            var xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/json");
            xobj.open('GET', file, true); // Replace 'my_data' with the path to your file
            xobj.onreadystatechange = function() {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
                    callback(xobj.responseText);
                }
            };
            xobj.send(null);
        }

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();
        scenes[0] = scene;

        // create a camera, which defines where we're looking at.   window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000


        //var camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 60000);
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 60000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        //renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setClearColor(new THREE.Color(0x454b3a));
        renderer.setSize(window.innerWidth, window.innerHeight);


        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);


        // position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 2000;
        //camera.lookAt(new THREE.Vector3(20, 30, 0));
        cameras[0] = camera;

        texture = new THREE.Texture(canvas);
        var materialLabel = new THREE.SpriteMaterial({
            map: texture
        });

        ObjectLabel = new THREE.Sprite(materialLabel);
        ObjectLabel.name = "VolumeLabel";
        ObjectLabel.position.x = camera.position.x;
        ObjectLabel.position.y = camera.position.y;
        ObjectLabel.position.z = camera.position.z;
        scene.add(ObjectLabel);

        canvas.width = 256.;
        canvas.height = 256.;

        //Mouse events listeners 
        renderer.domElement.addEventListener('mousedown', onEventMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onEventMouseUp, false);
        //renderer.domElement.addEventListener('dblclick' , onEventDblClick,  false);
        renderer.domElement.addEventListener('mousemove', onEventMouseMove, false);

        window.addEventListener('resize', onWindowResize, false);


        // Trackball controls for rotating and moving the camera

        var trackballControls = new THREE.OrbitControls(camera, renderer.domElement);
        trackballControls.target.set(0, 0, 0);
        trackballControls.update();


        //Lighting
        var ambientLight = new THREE.AmbientLight(0x99ff99);
        scene.add(ambientLight);
        var spotLight = new THREE.SpotLight(0xffffff);
        var dirLight = new THREE.DirectionalLight(0x55505a, 1);
        setSpotDirLight();
        scene.add(spotLight);
        scene.add(dirLight);

        keyboard = new THREEx.KeyboardState();
        var MenuPtr = CreateMenu();
        MenuItems = MenuPtr;

        trackballControls.enabled = MenuItems.EnableMouseTrackBall;

        renderer.localClippingEnabled = false;

        var TimeStamp = 0.0;
        var TimeStep = 0.02; //seconds

        var scale = 3;

        //AddPrimitives(scene);

        //var axisHelper = new THREE.AxisHelper(500);
        //scene.add(axisHelper);

        animate();

        //============================

        function disposeGeoStructure(node) {
            for (var i = 0; i < node.children.length; i++) {
                disposeGeoStructure(node);
            }
            if (node instanceof THREE.Mesh) {

                node.parent.remove(node);
                geoList[node.geoId] = null;
                node.geometry.dispose();
                node.material.dispose();

            }
        }



        function setSpotDirLight() {

            spotLight.angle = Math.PI / 5;
            spotLight.penumbra = 0.2;
            spotLight.position.set(12000, 12000, -12000);
            spotLight.castShadow = true;
            spotLight.shadow.camera.near = 3;
            spotLight.shadow.camera.far = 10;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;

            dirLight.position.set(0, 3000, 0);
            dirLight.castShadow = true;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 10;
            dirLight.shadow.camera.right = 1;
            dirLight.shadow.camera.left = -1;
            dirLight.shadow.camera.top = 1;
            dirLight.shadow.camera.bottom = -1;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;

        }



        function checkTraverse(intersectsUnique, intersects) {
            //Check if traversed (same object pointed fron the oposite side)
            var items = 0;
            nv = intersects.length;
            if (intersects[0].object.name == "VolumeLabel") {
                if (nv > 1) intersectsUnique[0] = intersects[1];
                else return items;
                var ii = 1;
            } else {
                var ii = 0;
                intersectsUnique[0] = intersects[0];
            }
            for (var i = ii; i < nv; i++) {
                var notFound = true;
                for (var j = 0; j < intersectsUnique.length; j++) {
                    if (intersects[i].object == intersectsUnique[j].object) {
                        notFound = false;
                        break;
                    }
                }
                if (notFound && (intersects[i].object.name != "VolumeLabel")) {
                    items++;
                    intersectsUnique[items] = intersects[i];
                }
            }
            return items;
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        function onEventMouseDown(event) {
            event.preventDefault();
            var saveTrackballControlsStatus = trackballControls.enabled;



            if (MenuItems.ShowTree) {

                trackballControls.enableRotate = false;
                var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
                vector = vector.unproject(camera);

                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                var intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    for (var i=0;i<intersects.length;i++){
                        console.log(i,intersects.length,intersects[i]);
                    }
                }

            } else if (MenuItems.EnableMouseActions) {
                var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
                vector = vector.unproject(camera);

                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                var intersects = raycaster.intersectObjects(scene.children, true);


                trackballControls.enableRotate = true;

                if (intersects.length > 0) {

                    var intersectsUnique = [];
                    checkTraverse(intersectsUnique, intersects);

                    trackballControls.enabled = true;

                    if (keyboard.pressed("shift+Z")) {
                        restoreVol(intersectsUnique);
                    } else {
                        var lastObject = -1
                        for (var i = 0; i < intersectsUnique.length; i++) {
                            if (!intersectsUnique[i].object.material.visible || intersectsUnique[i].object.material.wireframe || intersectsUnique[i].object.material.transparent) {
                                lastObject++
                            } else {
                                lastObject++
                                break;
                            }
                        }
                        if (lastObject >= 0) {
                            if (keyboard.pressed("ctrl")) newmat = intersectsUnique[lastObject].object.material.clone();

                            if (keyboard.pressed("ctrl+w")) {
                                newmat.wireframe = true;
                                intersectsUnique[lastObject].object.material = newmat;
                            } else if (keyboard.pressed("shift+W")) {
                                intersectsUnique[lastObject].object.material.wireframe = true;
                            } else if (keyboard.pressed("ctrl+t")) {
                                newmat.opacity = 0.3;
                                newmat.transparent = true;
                                intersectsUnique[lastObject].object.material = newmat;
                            } else if (keyboard.pressed("shift+T")) {
                                intersectsUnique[lastObject].object.material.transparent = true;
                            } else if (keyboard.pressed("ctrl")) {
                                newmat.visible = false;
                                intersectsUnique[lastObject].object.material = newmat;
                            } else if (keyboard.pressed("shift")) {
                                intersectsUnique[lastObject].object.material.visible = false;
                            }
                        }
                    }
                    trackballControls.enabled = saveTrackballControlsStatus;
                }
            }
        }

        function restoreMouseOperations(vol = root) {
            for (var i = 0; i < vol.children.length; i++) {
                restoreMouseOperations(vol.children[i]);
            }
            if (vol.material) {
                vol.material.wireframe = false;
                vol.material.transparent = false;
                vol.material.visible = true;
            }
        }

        function onEventMouseUp(event) {
            event.preventDefault();
            if (MenuItems.EnableMouseTrackBall) trackballControls.enabled = true;
        }


        function restoreVol(intersects) {

            trackballControls.enabled = false;

            var lastObject = -1;
            for (var i = 0; i < intersects.length; i++) {

                if (!intersects[i].object.material.visible || intersects[i].object.material.wireframe || intersects[i].object.material.transparent) {
                    lastObject = i;
                } else {
                    lastObject = i - 1;
                    break;
                }
            }
            if (lastObject >= 0) {
                if (intersects[lastObject].object.material.wireframe) {
                    intersects[lastObject].object.material.wireframe = false;
                } else if (intersects[lastObject].object.material.transparent) {
                    intersects[lastObject].object.material.transparent = false;
                } else if (!intersects[lastObject].object.material.visible) {
                    intersects[lastObject].object.material.visible = true;
                }
            }
        }



        function onEventMouseMove(event) {
            event.preventDefault();

            //    if (!MenuItems.EnableMouseTrackBall && MenuItems.VolumeLabel){
            if (MenuItems.ShowTree) {




            } else if (MenuItems.VolumeLabel) {
                var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
                var vector1 = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -((event.clientY - 33) / window.innerHeight) * 2 + 1, 0.5);
                vector = vector.unproject(camera);
                vector1 = vector1.unproject(camera);
                //console.log(event.clientX,event.clientY,window.innerWidth,window.innerHeight)

                ObjectLabel.position.x = vector1.x;
                ObjectLabel.position.y = vector1.y;
                ObjectLabel.position.z = vector1.z;

                var v = ObjectLabel.position.clone().applyMatrix4(camera.matrixWorldInverse);
                var virtualDistanceScale = 10 * camera.position.z;
                var sf = Math.abs((v.z - camera.position.z) / virtualDistanceScale);
                ObjectLabel.scale.set(sf, sf, sf);

                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                var intersects = raycaster.intersectObjects(scene.children, true);


                if (intersects.length > 0) {

                    var intersectsUnique = [];
                    checkTraverse(intersectsUnique, intersects);

                    var lastObject = -1
                        //console.log(intersectsUnique);
                    for (var i = 0; i < intersectsUnique.length; i++) {
                        if (!intersectsUnique[i].object.material.visible || intersectsUnique[i].object.material.wireframe || intersectsUnique[i].object.material.transparent) {
                            lastObject++
                        } else {
                            lastObject++
                            break;
                        }
                    }
                    if (lastObject >= 0) {
                        VolumeName = intersectsUnique[lastObject].object.name;
                    } else {
                        VolumeName = "";
                    }
                    changeCanvas(VolumeName);
                    texture.needsUpdate = true;
                }
            }
        }


        function TraceParticles(i, visible, nsteps) {
            line = ParticlesTraceInScene.children[i];
            line.visible = visible;
            line.geometry.setDrawRange(0, nsteps - 1);
        }

        function animate() {

            var delta = ParticleClock.getDelta();
            trackballControls.update(delta);

            var flyTime = (ParticleClock.getElapsedTime() - LastElapsed);

            var rmat = Math.round(flyTime) % 3;

            if (MenuItems.ShowTree) {




            } else {

                if (CurrentTimeSlot < NtimeSlots) {

                    var spt = SetOfParticlesInTime.Event[CurrentTimeSlot];
                    var slotTime = spt.time / 1000.

                    flyTime = flyTime * MenuItems.particleSpeedScaleFactor;

                    if (slotTime <= flyTime) {

                        for (var i = 0; i < spt.pset.length; i++) {
                            var v = spt.pset[i].pos;
                            var kind = spt.pset[i].kind;

                            //visible
                            ParticlesInScene.children[i].visible = ParticleKindVisible[kind];

                            //position
                            if (spt.pset[i].type == "a") {
                                ParticlesInScene.children[i].position.x = v[0];
                                ParticlesInScene.children[i].position.y = v[1];
                                ParticlesInScene.children[i].position.z = v[2];

                                ParticlesInScene.children[i].name = ParticleKind[kind];
                                //material/kind
                                ParticlesInScene.children[i].material = ParticleMaterial[kind];
                                //scale
                                ParticlesInScene.children[i].scale.set(MenuItems.particlesSizeScaleFactor, MenuItems.particlesSizeScaleFactor, 1.);
                                if (MenuItems.traceParticles) TraceParticles(i, ParticleKindVisible[kind], spt.pset[i].nsteps);

                            } else {
                                ParticlesInScene.children[i].material = ReactedParticleMaterial[rmat];
                                ParticlesInScene.children[i].scale.set(MenuItems.ReactedParticlesSizeScaleFactor, MenuItems.ReactedParticlesSizeScaleFactor, 1.);
                                //if (MenuItems.traceParticles) TraceParticles(i, ParticleKindVisible[kind], spt.pset[i].nsteps);
                                //ParticlesInScene.children[i].visible = false;
                            }

                            //Trace particles
                        }

                        CurrentTimeSlot++;

                    }
                } else { // display only blinking reacted  vertices

                    if (NtimeSlots > 0) {
                        var spt = SetOfParticlesInTime.Event[CurrentTimeSlot - 1];
                        for (var i = 0; i < spt.pset.length; i++) {
                            var kind = spt.pset[i].kind;
                            if (spt.pset[i].type == "a") {
                                ParticlesInScene.children[i].visible = false;
                            } else {
                                ParticlesInScene.children[i].material = ReactedParticleMaterial[rmat];
                                ParticlesInScene.children[i].scale.set(MenuItems.ReactedParticlesSizeScaleFactor, MenuItems.ReactedParticlesSizeScaleFactor, 1.);
                                ParticlesInScene.children[i].visible = ParticleKindVisible[kind]
                                if (MenuItems.traceParticles) TraceParticles(i, ParticleKindVisible[kind], spt.pset[i].nsteps);
                            }
                        }
                    }
                    //ParticleClock.stop();
                    if (MenuItems.restartParticles) RestartParticles();
                }
            }
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }




        function load() {
            //spinner = showSpinner();
            fileInput.click();
        }
    }

    window.onload = init;
    </script>
</body>

</html>
